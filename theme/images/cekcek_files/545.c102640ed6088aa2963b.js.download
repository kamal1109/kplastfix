(window.webpackJsonp=window.webpackJsonp||[]).push([[545],{kqpF:function(e,t){e.exports={keywords:["not","or","and","if","else","for","to","by","break","continue","var","int","float","bool","color","string","line","label","table","varip"],operators:{title:$.t("Language Operators"),prefix:"op_",docs:{"?:":{name:"?:",desc:[$.t("Ternary conditional operator.",{context:"pine_docs_desc"})],syntax:["expr1 ? expr2 : expr3"],returns:[$.t("expr2 if expr1 is evaluated to true, expr3 otherwise. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true.",{context:"pine_docs_returns"})],remarks:[$.t("Use {@var na} for 'else' branch if you do not need it.",{context:"pine_docs_remarks"}),$.t("You can combine two or more {@op ?:} operators to achieve the equivalent of a 'switch'-like statement (see examples above).",{context:"pine_docs_remarks"}),$.t("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.",{context:"pine_docs_remarks"})],examples:["// Draw circles at the bars where open crosses close","s2 = cross(open, close) ? avg(open,close) : na","plot(s2, style=plot.style_circles, linewidth=2, color=color.red)","","// Combination of ?: operators for 'switch'-like logic","c = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray","plot(hl2, color=c)"],seeAlso:["{@fun iff}, {@fun na}"]},"+":{desc:[$.t("Addition or unary plus. Applicable to numerical expressions or strings.",{context:"pine_docs_desc"})],syntax:["expr1 + expr2","+ expr"],returns:[$.t("Binary `+` for strings returns concatenation of expr1 and expr2",{context:"pine_docs_returns"}),$.t("For numbers returns integer or float value, or series of values:",{context:"pine_docs_returns"}),$.t("Binary `+` returns expr1 plus expr2.",{context:"pine_docs_returns"}),$.t("Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator).",{context:"pine_docs_returns"})],remarks:[$.t("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.",{context:"pine_docs_remarks"})]},"-":{desc:[$.t("Subtraction or unary minus. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 - expr2","- expr"],returns:[$.t("Returns integer or float value, or series of values:",{context:"pine_docs_returns"}),$.t("Binary `-` returns expr1 minus expr2.",{context:"pine_docs_returns"}),$.t("Unary `-` returns the negation of expr.",{context:"pine_docs_returns"})],remarks:[$.t("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.",{context:"pine_docs_remarks"})]},"[]":{name:"[]",desc:[$.t("Series subscript. Provides access to previous values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be rounded down.",{context:"pine_docs_desc"})],
syntax:["expr1[expr2]"],returns:[$.t("A series of values",{context:"pine_docs_returns"})],examples:['// [] can be used to "save" variable value between bars',"a = 0.0 // declare `a`","a := a[1] // immediately set current value to the same as previous. `na` in the beginning of history","if high == low // if some condition - change `a` value to another","    a := low"],seeAlso:["{@fun floor}"]},"==":{desc:[$.t("Equal to. Applicable to expressions of any type.",{context:"pine_docs_desc"})],syntax:["expr1 == expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},"!=":{desc:[$.t("Not equal to. Applicable to expressions of any type.",{context:"pine_docs_desc"})],syntax:["expr1 != expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},">":{desc:[$.t("Greater than. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 > expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},"<":{desc:[$.t("Less than. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 < expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},">=":{desc:[$.t("Greater than or equal to. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 >= expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},"<=":{desc:[$.t("Less than or equal to. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 <= expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},"*":{desc:[$.t("Multiplication. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 * expr2"],returns:[$.t("Integer or float value, or series of values",{context:"pine_docs_returns"})]},"/":{desc:[$.t("Division. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 / expr2"],returns:[$.t("Integer or float value, or series of values",{context:"pine_docs_returns"})]},"%":{desc:[$.t("Modulo (integer remainder). Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 % expr2"],remarks:[$.t("In Pine Script, when the integer remainder is calculated, the quotient is truncated, i.e. rounded towards the lowest absolute value. The resulting value will have the same sign as the dividend.",{context:"pine_docs_remarks"}),$.t("Example: -1 % 9 = -1 - 9 * truncate(-1/9) = -1 - 9 * truncate(-0.111) = -1 - 9 * 0 = -1.",{context:"pine_docs_remarks"})],returns:[$.t("Integer or float value, or series of values",{context:"pine_docs_returns"})]},"+=":{desc:[$.t("Addition assignment. Applicable to numerical expressions or strings.",{context:"pine_docs_desc"})],syntax:["expr1 += expr2"],remarks:[$.t("You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise.",{context:"pine_docs_remarks"})],
examples:["// Equals to expr1 = expr1 + expr2.","a = 2","b = 3","a += b","// Result: a = 5."],returns:[$.t("For strings returns concatenation of expr1 and expr2. For numbers returns integer or float value, or series of values.",{context:"pine_docs_returns"})]},"-=":{desc:[$.t("Subtraction assignment. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 -= expr2"],examples:["// Equals to expr1 = expr1 - expr2.","a = 2","b = 3","a -= b","// Result: a = -1."],returns:[$.t("Integer or float value, or series of values.",{context:"pine_docs_returns"})]},"*=":{desc:[$.t("Multiplication assignment. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 *= expr2"],examples:["// Equals to expr1 = expr1 * expr2.","a = 2","b = 3","a *= b","// Result: a = 6."],returns:[$.t("Integer or float value, or series of values.",{context:"pine_docs_returns"})]},"/=":{desc:[$.t("Division assignment. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 /= expr2"],examples:["// Equals to expr1 = expr1 / expr2.","a = 3","b = 3","a /= b","// Result: a = 1."],returns:[$.t("Integer or float value, or series of values.",{context:"pine_docs_returns"})]},"%=":{desc:[$.t("Modulo assignment. Applicable to numerical expressions.",{context:"pine_docs_desc"})],syntax:["expr1 %= expr2"],examples:["// Equals to expr1 = expr1 % expr2.","a = 3","b = 3","a %= b","// Result: a = 0."],returns:[$.t("Integer or float value, or series of values.",{context:"pine_docs_returns"})]},or:{desc:[$.t("Logical OR. Applicable to boolean expressions.",{context:"pine_docs_desc"})],syntax:["expr1 or expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},and:{desc:[$.t("Logical AND. Applicable to boolean expressions.",{context:"pine_docs_desc"})],syntax:["expr1 and expr2"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},not:{desc:[$.t("Logical negation (NOT). Applicable to boolean expressions.",{context:"pine_docs_desc"})],syntax:["not expr1"],returns:[$.t("Boolean value, or series of boolean values.",{context:"pine_docs_returns"})]},if:{desc:[$.t("If statement defines what block of statements must be executed when conditions of the expression are satisfied.",{context:"pine_docs_desc"}),$.t("To have access to and use the if statement, one should specify the version >= 2 of Pine Script language in the very first line of code, for example: {dont_translate_1}",{context:"pine_docs_desc"}).format({dont_translate_1:"//@version=4"}),$.t("The 4th version of Pine Script Language allows you to use “else if” syntax.",{context:"pine_docs_desc"}),$.t("General code form:",{context:"pine_docs_desc"})],
syntax:["var_declarationX = if condition<br>&ensp;&emsp;var_decl_then0<br>&ensp;&emsp;var_decl_then1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_thenN<br>else if [optional block]<br>&ensp;&emsp;var_decl_else0<br>&ensp;&emsp;var_decl_else1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_elseN<br>else<br>&ensp;&emsp;var_decl_else0<br>&ensp;&emsp;var_decl_else1<br>&ensp;&emsp;…<br>&ensp;&emsp;var_decl_elseN<br>&ensp;&emsp;return_expression_else"],detailedDesc:[{desc:[$.t("where",{context:"pine_docs_desc"}),$.t("{b_on}var_declarationX{b_off} — this variable gets the value of the if statement",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}condition{b_off} — if the condition is true, the logic from the block 'then' (var_decl_then0, var_decl_then1, etc.) is used.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("If the condition is false, the logic from the block 'else' (var_decl_else0, var_decl_else1, etc.) is used.",{context:"pine_docs_desc"}),$.t("{b_on}return_expression_then{b_off}, {b_on}return_expression_else{b_off} — the last expression from the block then or from the block else will return the final value of the statement. If declaration of the variable is in the end, its value will be the result.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("The type of returning value of the if statement depends on return_expression_then and return_expression_else type (their types must match: it is not possible to return an integer value from then, while you have a string value in else block).",{context:"pine_docs_desc"})],examples:["// This code compiles","x = if close > open","    close","else","    open","// This code doesn’t compile","else","x = if close > open","    close","else",'    "open"']},{desc:[$.t("It is possible to omit the else block. In this case if the condition is false, an “empty” value (na, false, or “”) will be assigned to the var_declarationX variable:",{context:"pine_docs_desc"})],examples:["x = if close > open","    close","// If current close > current open, then x = close.","// Otherwise the x = na."]},{desc:[$.t("It is possible to use either multiple “else if” blocks or none at all:",{context:"pine_docs_desc"})],examples:["x = if open > close","    5","else if high > low","    close","else","    open"]},{desc:[$.t("The blocks “then”, “else if”, “else” are shifted by four spaces. If statements can include each other, +four spaces:",{context:"pine_docs_desc"})],examples:["x = if close > open","    b = if close > close[1]","        close","    else","        close[1]","    b","else","    open"]},{desc:[$.t("It is possible to ignore the resulting value of an if statement (“var_declarationX=“ can be omited). It may be useful if you need the side effect of the expression, for example in strategy trading:",{context:"pine_docs_desc"})],
examples:["if (crossover(source, lower))",'    strategy.entry("BBandLE", strategy.long, stop=lower,','        oca_name="BollingerBands",','    oca_type=strategy.oca.cancel, comment="BBandLE")',"else",'    strategy.cancel(id="BBandLE")']}]},for:{desc:[$.t("For statement allows to execute a number of instructions repeatedly.",{context:"pine_docs_desc"}),$.t("To have access to and use the for statement, one should specify the version >= 2 of Pine Script language in the very first line of code, for example: {dont_translate_1}",{context:"pine_docs_desc"}).format({dont_translate_1:"//@version=4"})],syntax:["var_declarationX = for counter = from_num to to_num [by step_num]<br>&ensp;&emsp;var_decl0<br>&ensp;&emsp;var_decl1<br>&ensp;&emsp;…<br>&ensp;&emsp;continue<br>&ensp;&emsp;…<br>&ensp;&emsp;break<br>&ensp;&emsp;…<br>&ensp;&emsp;var_declN<br>&ensp;&emsp;return_expression"],detailedDesc:[{desc:[$.t("where:",{context:"pine_docs_desc"}),$.t("{b_on}counter{b_off} - a variable, loop counter.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}from_num{b_off} - start value of the counter",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}to_num{b_off} - end value of the counter. When the counter becomes greater than to_num (or less than to_num in case from_num > to_num) the loop is broken.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}step_num{b_off} - loop step. Can be omitted (in the case loop step = 1). If from_num is greater than to_num loop step will change direction automatically, no need to specify negative numbers.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}var_decl0{b_off}, {b_on}… var_declN{b_off}, {b_on}return_expression{b_off} - body of the loop. It must be shifted by 4 spaces or 1 tab.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}return_expression{b_off} - returning value. When a loop is finished or broken, the returning value is given to the var_declarationX.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}continue{b_off} - a keyword. Can be used only in loops. It switches the loop to next iteration.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}break{b_off} - a keyword. Can be used only in loops. It breaks the loop.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"})],examples:["//@version=4",'study("My sma")',"my_sma(price, length) =>","    sum = price","    for i = 1 to length-1","        sum := sum + price[i]","    sum / length","plot(my_sma(close,14))"]}],remarks:$.t("Variable ‘sum’ is a mutable variable and a new value can be given to it by an operator := in body of the loop. Also note that we recommend to use a built-in function {@fun sma} for Moving Average as it calculates faster.",{context:"pine_docs_remarks"}),seeAlso:["{@fun sum}"]},var:{desc:[$.t("{b_on}var{b_off} is the keyword used for assigning and one-time initializing of the variable.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"
}),$.t("Normally, a syntax of assignment of variables, which doesn’t include the keyword var, results in the value of the variable being overwritten with every update of the data. Contrary to that, when assigning variables with the keyword var, they can “keep the state” despite the data updating, only changing it when conditions within if-expressions are met.",{context:"pine_docs_desc"}),$.t("Available starting from version 4.",{context:"pine_docs_desc"})],syntax:["var variable_name = expression"],detailedDesc:[{desc:[$.t("where:",{context:"pine_docs_desc"}),$.t("{b_on}variable_name{b_off} - any name of the user’s variable that’s allowed in Pine Script (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can’t start with a number).",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}expression{b_off} - any arithmetic expression, just as with defining a regular variable. The expression will be calculated and assigned to a variable once.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"})],examples:["//@version=4",'study("Var keyword example")',"var a = close","var b = 0.0","var c = 0.0","var green_bars_count = 0","if close > open","\tvar x = close","\tb := x","\tgreen_bars_count := green_bars_count + 1","\tif green_bars_count >= 10","\t\tvar y = close","\t\tc := y","plot(a)","plot(b)","plot(c)"]},{desc:[$.t("The variable ‘a‘ keeps the closing price of the first bar for each bar in the series.",{context:"pine_docs_desc"}),$.t("The variable ‘b‘ keeps the closing price of the first “green” bar in the series.",{context:"pine_docs_desc"}),$.t("The variable ‘c‘ keeps the closing price of the tenth “green” bar in the series.",{context:"pine_docs_desc"})]}]},varip:{desc:[$.t("{b_on}varip{b_off} (var intrabar persist) is the keyword used for assigning and one-time initializing of a variable. It is similar to the var keyword, but variables declared with varip retain their values between the updates of a real-time bar.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"})],syntax:["varip variable_name = expression"],detailedDesc:[{desc:[$.t("where:",{context:"pine_docs_desc"}),$.t("{b_on}variable_name{b_off} - any name of the user's variable that's allowed in Pine Script (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can't start with a number).",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"}),$.t("{b_on}expression{b_off} - any arithmetic expression, just as when defining a regular variable. The expression will be calculated and assigned to the variable only once, on the first bar.",{context:"pine_docs_desc"}).format({b_on:"<b>",b_off:"</b>"})],examples:["//@version=4","study('varip')","varip int v = -1","v := v + 1","plot(v)"]},{desc:[$.t("With var, the plot would return the value of bar_index. With varip, the same behavior occurs on historical bars, but in the real-time bar, the plot returns a value that increases by one for each tick.",{context:"pine_docs_desc"})]}],
remarks:$.t("Can be used only with simple types such as float, int, bool, string, and with arrays of these types.",{context:"pine_docs_remarks"})}}},variables:{title:$.t("Built-in Variables"),prefix:"var_",docs:{"input.bool":{name:"input.bool",type:"const string",desc:[$.t("Is a named constant for bool input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.integer":{name:"input.integer",type:"const string",desc:[$.t("Is a named constant for integer input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.float":{name:"input.float",type:"const string",desc:[$.t("Is a named constant for float input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.string":{name:"input.string",type:"const string",desc:[$.t("Is a named constant for string input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.symbol":{name:"input.symbol",type:"const string",desc:[$.t("Is a named constant for symbol input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.resolution":{name:"input.resolution",type:"const string",desc:[$.t("Is a named constant for resolution input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.session":{name:"input.session",type:"const string",desc:[$.t("Is a named constant for session input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.source}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.source":{name:"input.source",type:"const string",desc:[$.t("Is a named constant for source input type of {@fun input} function.",{context:"pine_docs_desc"})],
seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.color}, {@var input.time}, {@fun input}"]},"input.color":{name:"input.color",type:"const string",desc:[$.t("Is a named constant for color input type of {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.time}, {@fun input}"]},"input.time":{name:"input.time",type:"const string",desc:[$.t("Is a named constant for the time type of the {@fun input} function.",{context:"pine_docs_desc"})],seeAlso:["{@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@fun input}"]},bar_index:{name:"bar_index",type:"series[integer]",desc:[$.t("Current bar index. Numbering is zero-based, index of the first bar is 0.",{context:"pine_docs_desc"})],remarks:[$.t("Note that {b_on}bar_index{b_off} has replaced {b_on}n{b_off} variable in version 4.",{context:"pine_docs_remarks"}).format({b_on:"<b>",b_off:"</b>"}),$.t("Note that bar indexing starts from 0 on the first historical bar.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})],examples:["plot(bar_index)","plot(bar_index > 5000 ? close : 0)"]},na:{name:"na",type:"na",desc:[$.t("Double.NaN value (Not a Number).",{context:"pine_docs_desc"})],remarks:[$.t("Use it for return values ONLY. DON'T TRY TO COMPARE WITH IT! If you need to check if some value is NaN, use built-in function {@fun na}.",{context:"pine_docs_remarks"})],examples:["bar_index < 10 ? na : close    // CORRECT","","close == na ? close[1] : close    // INCORRECT!","na(close) ? close[1] : close    // CORRECT"],seeAlso:["{@fun na} (function)"]},volume:{name:"volume",type:"series[float]",desc:[$.t("Current bar volume.",{context:"pine_docs_desc"})],remarks:[$.t("Previous values may be accessed with square brackets operator [], e.g. volume[1], volume[2].",{context:"pine_docs_remarks"})],seeAlso:["{@var open}, {@var high}, {@var low}, {@var close}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]},"math.pi":{name:"math.pi",type:"const float",desc:[$.t("Is a named constant for {html_markup_1}Archimedes' constant{html_markup_2}. It is equal to 3.1415926535897932.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://en.wikipedia.org/wiki/Pi">',html_markup_2:"</a>"})],seeAlso:["{@var math.e}, {@var math.phi}, {@var math.rphi}"]},"math.phi":{name:"math.phi",type:"const float",
desc:[$.t("Is a named constant for the {html_markup_1}golden ratio{html_markup_2}. It is equal to 1.6180339887498948.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://en.wikipedia.org/wiki/Golden_ratio">',html_markup_2:"</a>"})],seeAlso:["{@var math.e}, {@var math.pi}, {@var math.rphi}"]},"math.rphi":{name:"math.rphi",type:"const float",desc:[$.t("Is a named constant for the {html_markup_1}golden ratio conjugate{html_markup_2}. It is equal to 0.6180339887498948.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://en.wikipedia.org/wiki/Golden_ratio#Golden_ratio_conjugate">',html_markup_2:"</a>"})],seeAlso:["{@var math.e}, {@var math.pi}, {@var math.phi}"]},"math.e":{name:"math.e",type:"const float",desc:[$.t("Is a named constant for {html_markup_1}Euler's number{html_markup_2}. It is equal to 2.7182818284590452.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">',html_markup_2:"</a>"})],seeAlso:["{@var math.phi}, {@var math.pi}, {@var math.rphi}"]},open:{name:"open",type:"series[float]",desc:[$.t("Current open price.",{context:"pine_docs_desc"})],remarks:[$.t("Previous values may be accessed with square brackets operator [], e.g. open[1], open[2].",{context:"pine_docs_remarks"})],seeAlso:["{@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]},high:{name:"high",type:"series[float]",desc:[$.t("Current high price.",{context:"pine_docs_desc"})],remarks:[$.t("Previous values may be accessed with square brackets operator [], e.g. high[1], high[2].",{context:"pine_docs_remarks"})],seeAlso:["{@var open}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]},low:{name:"low",type:"series[float]",desc:[$.t("Current low price.",{context:"pine_docs_desc"})],remarks:[$.t("Previous values may be accessed with square brackets operator [], e.g. low[1], low[2].",{context:"pine_docs_remarks"})],seeAlso:["{@var open}, {@var high}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]},close:{name:"close",type:"series[float]",desc:[$.t("Current close price.",{context:"pine_docs_desc"})],remarks:[$.t("Previous values may be accessed with square brackets operator [], e.g. close[1], close[2].",{context:"pine_docs_remarks"})],seeAlso:["{@var open}, {@var high}, {@var low}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}, {@var ohlc4}"]},hl2:{name:"hl2",type:"series[float]",desc:[$.t("Is a shortcut for (high + low)/2",{context:"pine_docs_desc"})],seeAlso:["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hlc3}, {@var ohlc4}"]},hlc3:{name:"hlc3",type:"series[float]",desc:[$.t("Is a shortcut for (high + low + close)/3",{context:"pine_docs_desc"})],seeAlso:["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var ohlc4}"]},ohlc4:{name:"ohlc4",type:"series[float]",
desc:[$.t("Is a shortcut for (open + high + low + close)/4",{context:"pine_docs_desc"})],seeAlso:["{@var open}, {@var high}, {@var low}, {@var close}, {@var volume}, {@fun time}, {@var hl2}, {@var hlc3}"]},vwap:{name:"vwap",type:"series[float]",desc:[$.t("Volume-weighted average price. It uses hlc3 as a source series.",{context:"pine_docs_desc"})],seeAlso:["{@fun vwap} (function)"]},accdist:{name:"accdist",type:"series[float]",desc:[$.t("Accumulation/distribution index.",{context:"pine_docs_desc"})]},tr:{name:"tr",type:"series[float]",desc:[$.t("True range. Same as tr(false). It is max(high - low, abs(high - close[1]), abs(low - close[1]))",{context:"pine_docs_desc"})],seeAlso:["{@fun tr}, {@fun atr}"]},iii:{name:"iii",type:"series[float]",desc:[$.t("Intraday Intensity Index",{context:"pine_docs_desc"})],examples:["study('My Script')","plot(iii, color=color.yellow)","","// the same on pine","f_iii() =>","    return = (2 * close - high - low) / ((high - low) * volume)","","plot(f_iii())"]},wvad:{name:"wvad",type:"series[float]",desc:[$.t("Williams Variable Accumulation/Distribution",{context:"pine_docs_desc"})],examples:["study('My Script')","plot(wvad, color=color.yellow)","","// the same on pine","f_wvad() =>","    return = (close - open) / (high - low) * volume","","plot(f_wvad())"]},wad:{name:"wad",type:"series[float]",desc:[$.t("Williams Accumulation/Distribution",{context:"pine_docs_desc"})],examples:["study('My Script')","plot(wad, color=color.yellow)","","// the same on pine","f_wad() =>","    trueHigh = max(high, close[1])","    trueLow = min(low, close[1])","    mom = change(close)","    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0","    return = cum(gain)","","plot(f_wad())"]},obv:{name:"obv",type:"series[float]",desc:[$.t("On Balance Volume",{context:"pine_docs_desc"})],examples:["study('My Script')","plot(obv, color=color.yellow)","","// the same on pine","f_obv() =>","    return = cum(sign(change(close)) * volume)","","plot(f_obv())"]},pvt:{name:"pvt",type:"series[float]",desc:[$.t("Price-Volume Trend",{context:"pine_docs_desc"})],examples:["study('My Script')","plot(pvt, color=color.yellow)","","// the same on pine","f_pvt() =>","    return = cum((change(close) / close[1]) * volume)","","plot(f_pvt())"]},nvi:{name:"nvi",type:"series[float]",desc:[$.t("Negative Volume Index",{context:"pine_docs_desc"})],examples:["//@version=4","study('My Script')","","plot(nvi, color=color.yellow)","","// the same on pine","f_nvi() =>","    float nvi = 1.0","    float prevNvi = (nz(nvi[1], 0.0) == 0.0)  ? 1.0: nvi[1]","    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0","        nvi := prevNvi","    else","        nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi","    result = nvi","","plot(f_nvi())"]},pvi:{name:"pvi",type:"series[float]",desc:[$.t("Positive Volume Index",{context:"pine_docs_desc"})],
examples:["//@version=4","study('My Script')","","plot(pvi, color=color.yellow)","","// the same on pine","f_pvi() =>","    float pvi = 1.0","    float prevPvi = (nz(pvi[1], 0.0) == 0.0)  ? 1.0: pvi[1]","    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0","        pvi := prevPvi","    else","        pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi","    result = pvi","","plot(f_pvi())"]},"syminfo.ticker":{name:"syminfo.ticker",type:"string",desc:[$.t("Symbol name without exchange prefix, e.g. 'MSFT'",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.tickerid}, {@var timeframe.period}, {@var timeframe.multiplier}, {@var syminfo.root}"]},"syminfo.tickerid":{name:"syminfo.tickerid",type:"string",desc:[$.t("Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT'",{context:"pine_docs_desc"})],seeAlso:["{@fun tickerid} (function), {@var syminfo.ticker}, {@var timeframe.period}, {@var timeframe.multiplier}, {@var syminfo.root}"]},"timeframe.period":{name:"timeframe.period",type:"string",desc:[$.t("Resolution, e.g. '60' - 60 minutes, 'D' - daily, 'W' - weekly, 'M' - monthly, '5D' - 5 days, '12M' - one year, '3M' - one quarter",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.multiplier}"]},"syminfo.root":{name:"syminfo.root",type:"string",desc:[$.t("Root for derivatives like futures contract. For other symbols returns the same value as {@var syminfo.ticker}.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}, {@var syminfo.tickerid}"],examples:["For example if current chart ticker is 'CLM2014', would return 'CL'."]},"syminfo.prefix":{name:"syminfo.prefix",type:"string",desc:[$.t("Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD').",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}, {@var syminfo.tickerid}"],examples:["If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'."]},"syminfo.mintick":{name:"syminfo.mintick",type:"float",desc:[$.t("Min tick value for the current symbol.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.pointvalue}"]},"syminfo.pointvalue":{name:"syminfo.pointvalue",type:"float",desc:[$.t("Point value for the current symbol.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.mintick}"]},"syminfo.session":{name:"syminfo.session",type:"string",desc:[$.t("Session type of the chart main series. Possible values are {@var session.regular}, {@var session.extended}.",{context:"pine_docs_desc"})],seeAlso:["{@var session.regular}, {@var session.extended}."]},"syminfo.timezone":{name:"syminfo.timezone",type:"string",desc:[$.t("Timezone of the exchange of the chart main series. Possible values see in {@fun timestamp}.",{context:"pine_docs_desc"})],seeAlso:["{@fun timestamp}"]},"syminfo.description":{name:"syminfo.description",type:"string",desc:[$.t("Description for the current symbol.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}, {@var syminfo.prefix}"]},"syminfo.currency":{name:"syminfo.currency",
type:"string",desc:[$.t("Currency for the current symbol. Returns currency code: 'USD', 'EUR', etc.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.basecurrency}, {@var syminfo.ticker}, {@var currency.USD}, {@var currency.EUR}"]},"syminfo.basecurrency":{name:"syminfo.basecurrency",type:"string",desc:[$.t("Base currency for the symbol. For the symbol 'BTCUSD' returns 'BTC'.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.currency}, {@var syminfo.ticker}"]},"syminfo.type":{name:"syminfo.type",type:"string",desc:[$.t("Type of the current symbol. Possible values are stock, futures, index, forex, crypto, fund.",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}"]},"session.regular":{name:"session.regular",type:"const string",desc:[$.t("Constant for regular session type (no extended hours data).",{context:"pine_docs_desc"})],seeAlso:["{@var session.extended}, {@var syminfo.session}"]},"session.extended":{name:"session.extended",type:"const string",desc:[$.t("Constant for extended session type (with extended hours data).",{context:"pine_docs_desc"})],seeAlso:["{@var session.regular}, {@var syminfo.session}"]},"adjustment.none":{name:"adjustment.none",type:"const string",desc:[$.t("Constant for none adjustment type (no adjustment is applied).",{context:"pine_docs_desc"})],seeAlso:["{@var adjustment.splits}, {@var adjustment.dividends}, {@fun tickerid}"]},"adjustment.splits":{name:"adjustment.splits",type:"const string",desc:[$.t("Constant for splits adjustment type (splits adjustment is applied).",{context:"pine_docs_desc"})],seeAlso:["{@var adjustment.none}, {@var adjustment.dividends}, {@fun tickerid}"]},"adjustment.dividends":{name:"adjustment.dividends",type:"const string",desc:[$.t("Constant for dividends adjustment type (dividends adjustment is applied).",{context:"pine_docs_desc"})],seeAlso:["{@var adjustment.none}, {@var adjustment.splits}, {@fun tickerid}"]},"timeframe.multiplier":{name:"timeframe.multiplier",type:"integer",desc:[$.t("Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12",{context:"pine_docs_desc"})],seeAlso:["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.period}"]},"timeframe.isdwm":{name:"timeframe.isdwm",type:"bool",desc:[$.t("Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]},"timeframe.isintraday":{name:"timeframe.isintraday",type:"bool",desc:[$.t("Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdwm}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]},"timeframe.isdaily":{name:"timeframe.isdaily",type:"bool",desc:[$.t("Returns true if current resolution is a daily resolution, false otherwise.",{
context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]},"timeframe.isweekly":{name:"timeframe.isweekly",type:"bool",desc:[$.t("Returns true if current resolution is a weekly resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.ismonthly}"]},"timeframe.ismonthly":{name:"timeframe.ismonthly",type:"bool",desc:[$.t("Returns true if current resolution is a monthly resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}"]},"timeframe.isminutes":{name:"timeframe.isminutes",type:"bool",desc:[$.t("Returns true if current resolution is a minutes resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isseconds}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]},"timeframe.isseconds":{name:"timeframe.isseconds",type:"bool",desc:[$.t("Returns true if current resolution is a seconds resolution, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var timeframe.isdwm}, {@var timeframe.isintraday}, {@var timeframe.isminutes}, {@var timeframe.isdaily}, {@var timeframe.isweekly}, {@var timeframe.ismonthly}"]},"hline.style_solid":{name:"hline.style_solid",type:"const integer",desc:[$.t("Is a named constant for solid linestyle of {@fun hline} function.",{context:"pine_docs_desc"})],seeAlso:["{@var hline.style_dotted}, {@var hline.style_dashed}"]},"hline.style_dotted":{name:"hline.style_dotted",type:"const integer",desc:[$.t("Is a named constant for dotted linestyle of {@fun hline} function.",{context:"pine_docs_desc"})],seeAlso:["{@var hline.style_solid}, {@var hline.style_dashed}"]},"hline.style_dashed":{name:"hline.style_dashed",type:"const integer",desc:[$.t("Is a named constant for dashed linestyle of {@fun hline} function.",{context:"pine_docs_desc"})],seeAlso:["{@var hline.style_solid}, {@var hline.style_dotted}"]},"position.top_left":{name:"position.top_left",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the upper-left edge.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.top_center":{name:"position.top_center",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{
context:"pine_docs_desc"}),$.t("Binds the table to the top edge in the center.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.top_right":{name:"position.top_right",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the upper-right edge.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.middle_left":{name:"position.middle_left",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the left side of the screen.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.middle_center":{name:"position.middle_center",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the center of the screen.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.middle_right":{name:"position.middle_right",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the right side of the screen.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.bottom_left}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.bottom_left":{name:"position.bottom_left",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the bottom left of the screen.",{context:"pine_docs_desc"})],
seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_center},\t{@var position.bottom_right}"]},"position.bottom_center":{name:"position.bottom_center",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the bottom edge in the center.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left},\t{@var position.bottom_right}"]},"position.bottom_right":{name:"position.bottom_right",type:"const string",desc:[$.t("Table position is used in {@fun table.new}, {@fun table.cell} functions.",{context:"pine_docs_desc"}),$.t("Binds the table to the bottom right of the screen.",{context:"pine_docs_desc"})],seeAlso:["{@fun table.new}, {@fun table.cell}, {@fun table.set_position}, {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}"]},"size.auto":{name:"size.auto",type:"const string",desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape automatically adapts to the size of the bars.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}"]},"size.tiny":{name:"size.tiny",type:"const string",desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly tiny.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}"]},"size.small":{name:"size.small",type:"const string",desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly small.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.normal}, {@var size.large}, {@var size.huge}"]},"size.normal":{name:"size.normal",type:"const string",desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly normal.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.large}, {@var size.huge}"]},"size.large":{name:"size.large",type:"const string",
desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly large.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.huge}"]},"size.huge":{name:"size.huge",type:"const string",desc:[$.t("Size value for {@fun plotshape}, {@fun plotchar} functions. The size of the shape constantly huge.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun label.set_size}, {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}"]},"plot.style_line":{name:"plot.style_line",type:"const integer",desc:[$.t("Is a named constant for line style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_linebr":{name:"plot.style_linebr",type:"const integer",desc:[$.t("Is a named constant for line style of {@fun plot} function. Same as line but doesn't fill the breaks (gaps) in data.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_stepline":{name:"plot.style_stepline",type:"const integer",desc:[$.t("Is a named constant for stepline style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_histogram":{name:"plot.style_histogram",type:"const integer",desc:[$.t("Is a named constant for histogram style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_cross":{name:"plot.style_cross",type:"const integer",desc:[$.t("Is a named constant for cross style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_area":{name:"plot.style_area",type:"const integer",desc:[$.t("Is a named constant for area style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_areabr}, {@var plot.style_cross}, {@var plot.style_columns}, {@var plot.style_circles}"]},
"plot.style_areabr":{name:"plot.style_areabr",type:"const integer",desc:[$.t("Is a named constant for area style of {@fun plot} function. Same as area but doesn't fill the breaks (gaps) in data.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_columns}, {@var plot.style_circles}"]},"plot.style_columns":{name:"plot.style_columns",type:"const integer",desc:[$.t("Is a named constant for columns style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_circles}"]},"plot.style_circles":{name:"plot.style_circles",type:"const integer",desc:[$.t("Is a named constant for circles style of {@fun plot} function.",{context:"pine_docs_desc"})],seeAlso:["{@var plot.style_line}, {@var plot.style_linebr}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_areabr}, {@var plot.style_columns}"]},"format.inherit":{name:"format.inherit",type:"const string",desc:[$.t("Is a named constant for selecting the formatting of the script output values from the parent series in the {@fun study} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}, {@var format.price}, {@var format.volume}"]},"format.price":{name:"format.price",type:"const string",desc:[$.t("Is a named constant for selecting the formatting of the script output values as prices in the {@fun study} function.",{context:"pine_docs_desc"})],remarks:[$.t("If format is format.price, default precision value is set. You can use the precision argument of study function to change the precision value.",{context:"pine_docs_remarks"})],seeAlso:["{@fun study}, {@var format.inherit}, {@var format.volume}"]},"format.volume":{name:"format.volume",type:"const string",desc:[$.t("Is a named constant for selecting the formatting of the script output values as volume in the {@fun study} function, e.g. '5183' will be formatted as '5.183K'.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}, {@var format.inherit}, {@var format.price}"]},"format.percent":{name:"format.percent",type:"const string",desc:[$.t("Is a named constant for selecting the formatting of the script output values as a percentage in the study function. It adds a percent sign after values.",{context:"pine_docs_desc"})],remarks:[$.t("The default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the {@fun study} function.",{context:"pine_docs_remarks"})],seeAlso:["{@fun study}, {@var format.inherit}, {@var format.price}, {@var format.volume}"]},"format.mintick":{name:"format.mintick",type:"const string",
desc:[$.t("Is a named constant to use with the {@fun tostring} function. Passing a number to {@fun tostring} with this argument rounds the number to the nearest value that can be divided by {@var syminfo.mintick}, without the remainder, with ties rounding up, and returns the string version of said value with trailing zeroes.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}, {@var format.inherit}, {@var format.price}, {@var format.volume}"]},"dayofweek.sunday":{name:"dayofweek.sunday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]},"dayofweek.monday":{name:"dayofweek.monday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]},"dayofweek.tuesday":{name:"dayofweek.tuesday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]},"dayofweek.wednesday":{name:"dayofweek.wednesday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]},"dayofweek.thursday":{name:"dayofweek.thursday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.friday}, {@var dayofweek.saturday}"]},"dayofweek.friday":{name:"dayofweek.friday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.saturday}"]},"dayofweek.saturday":{name:"dayofweek.saturday",type:"const integer",desc:[$.t("Is a named constant for return value of {@fun dayofweek} function and value of {@var dayofweek} variable.",{context:"pine_docs_desc"})],
seeAlso:["{@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday}"]},timenow:{name:"timenow",type:"series[integer]",desc:[$.t("Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",{context:"pine_docs_desc"})],remarks:[$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})],seeAlso:["{@fun timestamp}, {@var time} (variable), {@var time_close}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},time:{name:"time",type:"series[integer]",desc:[$.t("Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the timestamp based on the time of the bar's open. Because of that, for overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day. For example, on EURUSD, `dayofmonth(time)` can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior.",{context:"pine_docs_remarks"})],seeAlso:["{@fun time} (function), {@var time_close}, {@var timenow}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},time_close:{name:"time_close",type:"series[integer]",desc:[$.t("Current bar close time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. On price-based charts this variable value is {@var na}.",{context:"pine_docs_desc"})],seeAlso:["{@var time}, {@var timenow}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},time_tradingday:{name:"time_tradingday",type:"series[integer]",desc:[$.t("The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970).",{context:"pine_docs_desc"})],remarks:[$.t("The variable is useful for overnight sessions, where the current day's session can start on the previous calendar day (e.g., on EURUSD the Monday session will start on Sunday, 17:00). Unlike `time`, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, `time_tradingday` will return the timestamp for Monday, 00:00.",{context:"pine_docs_remarks"}),$.t("When used on timeframes higher than 1D, `time_tradingday` returns the trading day of the last day inside the bar (e.g. on 1W, it will return the last trading day of the week).",{context:"pine_docs_remarks"})],
seeAlso:["{@var time}, {@var time_close}"]},year:{name:"year",type:"series[integer]",desc:[$.t("Current bar year in exchange timezone.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@fun year} (function), {@var time}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},month:{name:"month",type:"series[integer]",desc:[$.t("Current bar month in exchange timezone.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@fun month} (function), {@var time}, {@var year}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},weekofyear:{name:"weekofyear",type:"series[integer]",desc:[$.t("Week number of current bar time in exchange timezone.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@fun weekofyear} (function), {@var time}, {@var year}, {@var month}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},dayofmonth:{name:"dayofmonth",type:"series[integer]",desc:[$.t("Date of current bar time in exchange timezone.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@fun dayofmonth} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofweek}, {@var hour}, {@var minute}, {@var second}"]},dayofweek:{name:"dayofweek",type:"series[integer]",desc:[$.t("Day of week for current bar time in exchange timezone.",{context:"pine_docs_desc"})],remarks:[$.t("Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",{context:"pine_docs_remarks"}),$.t("You can use {@var dayofweek.sunday}, {@var dayofweek.monday}, {@var dayofweek.tuesday}, {@var dayofweek.wednesday}, {@var dayofweek.thursday}, {@var dayofweek.friday} and {@var dayofweek.saturday} variables for comparisons.",{context:"pine_docs_remarks"})],
seeAlso:["{@fun dayofweek} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var hour}, {@var minute}, {@var second}"]},hour:{name:"hour",type:"series[integer]",desc:[$.t("Current bar hour in exchange timezone.",{context:"pine_docs_desc"})],seeAlso:["{@fun hour} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var minute}, {@var second}"]},minute:{name:"minute",type:"series[integer]",desc:[$.t("Current bar minute in exchange timezone.",{context:"pine_docs_desc"})],seeAlso:["{@fun minute} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var second}"]},second:{name:"second",type:"series[integer]",desc:[$.t("Current bar second in exchange timezone.",{context:"pine_docs_desc"})],seeAlso:["{@fun second} (function), {@var time}, {@var year}, {@var month}, {@var weekofyear}, {@var dayofmonth}, {@var dayofweek}, {@var hour}, {@var minute}"]},"shape.xcross":{name:"shape.xcross",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.cross":{name:"shape.cross",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.circle":{name:"shape.circle",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.triangleup":{name:"shape.triangleup",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.triangledown":{name:"shape.triangledown",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.flag":{name:"shape.flag",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.arrowup":{name:"shape.arrowup",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.arrowdown":{name:"shape.arrowdown",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.labelup":{name:"shape.labelup",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.labeldown":{name:"shape.labeldown",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.square":{name:"shape.square",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}"]},"shape.diamond":{name:"shape.diamond",type:"const string",desc:[$.t("Shape style for {@fun plotshape} function.",{context:"pine_docs_desc"})],
seeAlso:["{@fun plotshape}"]},"location.abovebar":{name:"location.abovebar",type:"const string",desc:[$.t("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted above main series bars.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}"]},"location.belowbar":{name:"location.belowbar",type:"const string",desc:[$.t("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted below main series bars.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}"]},"location.top":{name:"location.top",type:"const string",desc:[$.t("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted near the top chart border.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.bottom}, {@var location.absolute}"]},"location.bottom":{name:"location.bottom",type:"const string",desc:[$.t("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted near the bottom chart border.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.absolute}"]},"location.absolute":{name:"location.absolute",type:"const string",desc:[$.t("Location value for {@fun plotshape}, {@fun plotchar} functions. Shape is plotted on chart using indicator value as a price coordinate.",{context:"pine_docs_desc"})],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}"]},"scale.right":{name:"scale.right",type:"const integer",desc:[$.t("Scale value for {@fun study} function. Study is added to the right price scale.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}"]},"scale.left":{name:"scale.left",type:"const integer",desc:[$.t("Scale value for {@fun study} function. Study is added to the left price scale.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}"]},"scale.none":{name:"scale.none",type:"const integer",desc:[$.t("Scale value for {@fun study} function. Study is added in 'No Scale' mode. Can be used only with 'overlay=true'.",{context:"pine_docs_desc"})],seeAlso:["{@fun study}"]},"strategy.oca.none":{name:"strategy.oca.none",type:"const string",desc:[$.t("OCA type value for strategy's functions. The parameter determines that an order should not belong to any particular OCO group.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]},"strategy.oca.cancel":{name:"strategy.oca.cancel",type:"const string",
desc:[$.t("OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where as soon as an order is filled, all other orders of the same group are cancelled. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]},"strategy.oca.reduce":{name:"strategy.oca.reduce",type:"const string",desc:[$.t("OCA type value for strategy's functions. The parameter determines that an order should belong to an OCO group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCO group is decreased by X. Note: if more than 1 guaranteed-to-be-executed orders of the same OCA group are placed at once, all those orders are filled.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]},"strategy.commission.percent":{name:"strategy.commission.percent",type:"const string",desc:[$.t("Commission type for an order. A percentage of the cash volume of order.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.commission.cash_per_contract":{name:"strategy.commission.cash_per_contract",type:"const string",desc:[$.t("Commission type for an order. Money displayed in the account currency per contract.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.commission.cash_per_order":{name:"strategy.commission.cash_per_order",type:"const string",desc:[$.t("Commission type for an order. Money displayed in the account currency per order.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.fixed":{name:"strategy.fixed",type:"const string",desc:[$.t("If the number of contracts/shares/lots/units to buy/sell is not specified for {@fun strategy.entry} or {@fun strategy.order} commands (or 'NaN' is specified), then the 'default_qty_value' is used to define the quantity.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.cash":{name:"strategy.cash",type:"const string",desc:[$.t("If the number of contracts/shares/lots/units to buy/sell is not specified for {@fun strategy.entry} or {@fun strategy.order} commands (or 'NaN' is specified), then strategy will calculate the quantity to buy/sell at close of current bar using the amount of money specified in the 'default_qty_value'.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.percent_of_equity":{name:"strategy.percent_of_equity",type:"const string",desc:[$.t("If the number of contracts/shares/lots/units to buy/sell is not specified for {@fun strategy.entry} or {@fun strategy.order} commands (or 'NaN' is specified), then strategy will calculate the quantity to buy/sell at close of current bar using the amount of money specified by the 'default_qty_value' in % from current strategy.equity (in the range from 0 to 100).",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.direction.all":{
name:"strategy.direction.all",type:"const string",desc:[$.t("It allows strategy to open both long and short positions.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.risk.allow_entry_in}"]},"strategy.direction.long":{name:"strategy.direction.long",type:"const string",desc:[$.t("It allows strategy to open only long positions.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.risk.allow_entry_in}"]},"strategy.direction.short":{name:"strategy.direction.short",type:"const string",desc:[$.t("It allows strategy to open only short positions.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.risk.allow_entry_in}"]},"strategy.position_size":{name:"strategy.position_size",type:"series[float]",desc:[$.t("Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size).",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_avg_price}"]},"strategy.position_avg_price":{name:"strategy.position_avg_price",type:"series[float]",desc:[$.t("Average entry price of current market position. If the market position is flat, 'NaN' is returned.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}"]},"strategy.openprofit":{name:"strategy.openprofit",type:"series[float]",desc:[$.t("Current unrealized profit or loss for the open position.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.netprofit}, {@var strategy.position_size}"]},"strategy.netprofit":{name:"strategy.netprofit",type:"series[float]",desc:[$.t("Total currency value of all completed trades.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.openprofit}, {@var strategy.position_size}, {@var strategy.grossprofit}, {@var strategy.grossloss}"]},"strategy.equity":{name:"strategy.equity",type:"series[float]",desc:[$.t("Current equity ( {@var strategy.initial_capital} + {@var strategy.netprofit} + {@var strategy.openprofit} ).",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.netprofit}, {@var strategy.openprofit}, {@var strategy.position_size}"]},"strategy.position_entry_name":{name:"strategy.position_entry_name",type:"string",desc:[$.t("Name of the order that initially opened current market position.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}"]},"strategy.grossprofit":{name:"strategy.grossprofit",type:"series[float]",desc:[$.t("Total currency value of all completed winning trades.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.netprofit}, {@var strategy.grossloss}"]},"strategy.grossloss":{name:"strategy.grossloss",type:"series[float]",desc:[$.t("Total currency value of all completed losing trades.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.netprofit}, {@var strategy.grossprofit}"]},"strategy.max_drawdown":{name:"strategy.max_drawdown",type:"series[float]",desc:[$.t("Maximum equity drawdown value for the whole trading interval.",{context:"pine_docs_desc"})],
seeAlso:["{@var strategy.netprofit}, {@var strategy.equity}"]},"strategy.max_contracts_held_all":{name:"strategy.max_contracts_held_all",type:"series[float]",desc:[$.t("Maximum number of contracts/shares/lots/units in one trade for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.max_contracts_held_long}, {@var strategy.max_contracts_held_short}"]},"strategy.max_contracts_held_long":{name:"strategy.max_contracts_held_long",type:"series[float]",desc:[$.t("Maximum number of contracts/shares/lots/units in one long trade for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.max_contracts_held_all}, {@var strategy.max_contracts_held_short}"]},"strategy.max_contracts_held_short":{name:"strategy.max_contracts_held_short",type:"series[float]",desc:[$.t("Maximum number of contracts/shares/lots/units in one short trade for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.max_contracts_held_all}, {@var strategy.max_contracts_held_long}"]},"strategy.opentrades":{name:"strategy.opentrades",type:"series[integer]",desc:[$.t("Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}"]},"strategy.closedtrades":{name:"strategy.closedtrades",type:"series[integer]",desc:[$.t("Number of trades, which were closed for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.wintrades}, {@var strategy.losstrades}, {@var strategy.eventrades}"]},"strategy.wintrades":{name:"strategy.wintrades",type:"series[integer]",desc:[$.t("Number of profitable trades for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.losstrades}, {@var strategy.eventrades}"]},"strategy.losstrades":{name:"strategy.losstrades",type:"series[integer]",desc:[$.t("Number of unprofitable trades for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.wintrades}, {@var strategy.eventrades}"]},"strategy.eventrades":{name:"strategy.eventrades",type:"series[integer]",desc:[$.t("Number of breakeven trades for the whole trading interval.",{context:"pine_docs_desc"})],seeAlso:["{@var strategy.position_size}, {@var strategy.opentrades}, {@var strategy.closedtrades}, {@var strategy.wintrades}, {@var strategy.losstrades}"]},"strategy.initial_capital":{name:"strategy.initial_capital",type:"series[float]",desc:[$.t("The amount of initial capital set in the strategy properties.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.NONE":{name:"currency.NONE",type:"const string",desc:[$.t("Unspecified currency.",{
context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.USD":{name:"currency.USD",type:"const string",desc:[$.t("United States dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.EUR":{name:"currency.EUR",type:"const string",desc:[$.t("Euro.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.AUD":{name:"currency.AUD",type:"const string",desc:[$.t(" Australian dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.GBP":{name:"currency.GBP",type:"const string",desc:[$.t("Pound sterling.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.NZD":{name:"currency.NZD",type:"const string",desc:[$.t("New Zealand dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.CAD":{name:"currency.CAD",type:"const string",desc:[$.t("Canadian dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.CHF":{name:"currency.CHF",type:"const string",desc:[$.t("Swiss franc.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.HKD":{name:"currency.HKD",type:"const string",desc:[$.t("Hong Kong dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.JPY":{name:"currency.JPY",type:"const string",desc:[$.t("Japanese yen.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.NOK":{name:"currency.NOK",type:"const string",desc:[$.t("Norwegian krone.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.SEK":{name:"currency.SEK",type:"const string",desc:[$.t("Swedish krona.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.SGD":{name:"currency.SGD",type:"const string",desc:[$.t("Singapore dollar.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.TRY":{name:"currency.TRY",type:"const string",desc:[$.t("Turkish lira.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.ZAR":{name:"currency.ZAR",type:"const string",desc:[$.t("South African rand.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"currency.RUB":{name:"currency.RUB",type:"const string",desc:[$.t("Russian ruble.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy}"]},"strategy.long":{name:"strategy.long",type:"const bool",desc:[$.t("Long position entry.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]},"strategy.short":{name:"strategy.short",type:"const bool",desc:[$.t("Short position entry.",{context:"pine_docs_desc"})],seeAlso:["{@fun strategy.entry}, {@fun strategy.exit}, {@fun strategy.order}"]},"barstate.isfirst":{name:"barstate.isfirst",type:"series[bool]",desc:[$.t("Returns true if current bar is first bar in barset, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"
}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.islast":{name:"barstate.islast",type:"series[bool]",desc:[$.t("Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.isfirst}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.ishistory":{name:"barstate.ishistory",type:"series[bool]",desc:[$.t("Returns true if current bar is a historical bar, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.isrealtime}, {@var barstate.isnew}, {@var barstate.isconfirmed}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.isrealtime":{name:"barstate.isrealtime",type:"series[bool]",desc:[$.t("Returns true if current bar is a real-time bar, false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isnew}, {@var barstate.isconfirmed}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.isnew":{name:"barstate.isnew",type:"series[bool]",desc:[$.t("Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar.",{context:"pine_docs_desc"})],
seeAlso:["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isconfirmed}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.isconfirmed":{name:"barstate.isconfirmed",type:"series[bool]",desc:[$.t("Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("It is NOT recommended to use {@var barstate.isconfirmed} in {@fun security} expression. Its value requested from {@fun security} is unpredictable.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"barstate.islastconfirmedhistory":{name:"barstate.islastconfirmedhistory",type:"series[bool]",desc:[$.t("Returns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.",{context:"pine_docs_desc"})],seeAlso:["{@var barstate.isfirst}, {@var barstate.islast}, {@var barstate.ishistory}, {@var barstate.isrealtime}, {@var barstate.isnew}"],remarks:[$.t("PineScript code that uses this variable could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})]},"session.ismarket":{name:"session.ismarket",type:"series[bool]",desc:[$.t("Returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise",{context:"pine_docs_desc"})],seeAlso:["{@var session.ispremarket}, {@var session.ispostmarket}"]},"session.ispremarket":{name:"session.ispremarket",type:"series[bool]",desc:[$.t("Returns true if the current bar is a part of the pre-market, false otherwise. On non-intraday charts always returns false.",{context:"pine_docs_desc"
})],seeAlso:["{@var session.ismarket}, {@var session.ispostmarket}"]},"session.ispostmarket":{name:"session.ispostmarket",type:"series[bool]",desc:[$.t("Returns true if the current bar is a part of the post-market, false otherwise. On non-intraday charts always returns false.",{context:"pine_docs_desc"})],seeAlso:["{@var session.ismarket}, {@var session.ispremarket}"]},"barmerge.lookahead_off":{name:"barmerge.lookahead_off",type:"const bool",desc:[$.t('Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from "future" on calculation on history.',{context:"pine_docs_desc"})],seeAlso:["{@fun security}, {@var barmerge.lookahead_on}"]},"barmerge.lookahead_on":{name:"barmerge.lookahead_on",type:"const bool",desc:[$.t('Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from "future" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators.',{context:"pine_docs_desc"})],seeAlso:["{@fun security}, {@var barmerge.lookahead_off}"]},"barmerge.gaps_off":{name:"barmerge.gaps_off",type:"const bool",desc:[$.t("Merge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value.",{context:"pine_docs_desc"})],seeAlso:["{@fun security}, {@var barmerge.gaps_on}"]},"barmerge.gaps_on":{name:"barmerge.gaps_on",type:"const bool",desc:[$.t("Merge strategy for requested data. Data is merged with possible gaps ({@var na} values).",{context:"pine_docs_desc"})],seeAlso:["{@fun security}, {@var barmerge.gaps_off}"]},"xloc.bar_index":{name:"xloc.bar_index",type:"const string",desc:[$.t("A named constant that specifies the algorithm of interpretation of x-value in functions {@fun line.new} and {@fun label.new}. If xloc = {@var xloc.bar_index}, value of x is a bar index",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun label.new}, {@fun line.set_xloc}, {@fun label.set_xloc}, {@var xloc.bar_time}"]},"xloc.bar_time":{name:"xloc.bar_time",type:"const string",desc:[$.t("A named constant that specifies the algorithm of interpretation of x-value in functions {@fun line.new} and {@fun label.new}. If xloc = {@var xloc.bar_time}, value of x is a bar UNIX time",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun label.new}, {@fun line.set_xloc}, {@fun label.set_xloc}, {@var xloc.bar_index}"]},"yloc.price":{name:"yloc.price",type:"const string",desc:[$.t("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.abovebar}, {@var yloc.belowbar}"]},"yloc.abovebar":{name:"yloc.abovebar",type:"const string",
desc:[$.t("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.price}, {@var yloc.belowbar}"]},"yloc.belowbar":{name:"yloc.belowbar",type:"const string",desc:[$.t("A named constant that specifies the algorithm of interpretation of y-value in function {@fun label.new}",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_yloc}, {@var yloc.price}, {@var yloc.abovebar}"]},"extend.none":{name:"extend.none",type:"const string",desc:[$.t("A named constant for {@fun line.new} and {@fun line.set_extend} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_extend}, {@var extend.left}, {@var extend.right}, {@var extend.both}"]},"extend.left":{name:"extend.left",type:"const string",desc:[$.t("A named constant for {@fun line.new} and {@fun line.set_extend} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.right}, {@var extend.both}"]},"extend.right":{name:"extend.right",type:"const string",desc:[$.t("A named constant for {@fun line.new} and {@fun line.set_extend} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.left}, {@var extend.both}"]},"extend.both":{name:"extend.both",type:"const string",desc:[$.t("A named constant for {@fun line.new} and {@fun line.set_extend} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_extend}, {@var extend.none}, {@var extend.left}, {@var extend.right}"]},"label.style_none":{name:"label.style_none",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_xcross":{name:"label.style_xcross",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},
"label.style_cross":{name:"label.style_cross",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_triangleup":{name:"label.style_triangleup",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_triangledown":{name:"label.style_triangledown",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_flag":{name:"label.style_flag",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_circle":{name:"label.style_circle",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_arrowup":{name:"label.style_arrowup",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_arrowdown":{name:"label.style_arrowdown",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_up":{name:"label.style_label_up",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_down":{name:"label.style_label_down",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_left":{name:"label.style_label_left",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_right":{name:"label.style_label_right",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_lower_left":{name:"label.style_label_lower_left",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_lower_right":{name:"label.style_label_lower_right",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_upper_left":{name:"label.style_label_upper_left",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_upper_right":{name:"label.style_label_upper_right",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_label_center":{name:"label.style_label_center",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_square}, {@var label.style_diamond}"]},"label.style_square":{name:"label.style_square",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_diamond}"]},"label.style_diamond":{name:"label.style_diamond",type:"const string",desc:[$.t("Label style for {@fun label.new} and {@fun label.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@fun label.set_textalign}, {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}"]},"display.none":{name:"display.none",type:"const integer",desc:[$.t("A named constant that specifies where the plot is displayed. Display nowhere. Available in alert template message",{context:"pine_docs_desc"})],seeAlso:["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]},"display.all":{name:"display.all",type:"const integer",desc:[$.t("A named constant that specifies where the plot is displayed. Display everywhere.",{context:"pine_docs_desc"})],seeAlso:["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun plotbar}, {@fun plotcandle}"]},"line.style_solid":{name:"line.style_solid",type:"const string",
desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]},"line.style_dotted":{name:"line.style_dotted",type:"const string",desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]},"line.style_dashed":{name:"line.style_dashed",type:"const string",desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]},"line.style_arrow_left":{name:"line.style_arrow_left",type:"const string",desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrow on the first point",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_right}, {@var line.style_arrow_both}"]},"line.style_arrow_right":{name:"line.style_arrow_right",type:"const string",desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrow on the second point",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_both}"]},"line.style_arrow_both":{name:"line.style_arrow_both",type:"const string",desc:[$.t("Line style for {@fun line.new} and {@fun line.set_style} functions. Solid line with arrows on both points",{context:"pine_docs_desc"})],seeAlso:["{@fun line.new}, {@fun line.set_style}, {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}"]},"text.align_center":{name:"text.align_center",type:"const string",desc:[$.t("Label text alignment for {@fun label.new} and {@fun label.set_textalign} functions.",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@var text.align_left}, {@var text.align_right}."]},"text.align_left":{name:"text.align_left",type:"const string",desc:[$.t("Label text alignment for {@fun label.new} and {@fun label.set_textalign} functions.",{context:"pine_docs_desc"})],seeAlso:["{@fun label.new}, {@fun label.set_style}, {@var text.align_center}, {@var text.align_right}."]},"text.align_right":{name:"text.align_right",type:"const string",desc:[$.t("Label text alignment for {@fun label.new} and {@fun label.set_textalign} functions.",{context:"pine_docs_desc"})],
seeAlso:["{@fun label.new}, {@fun label.set_style}, {@var text.align_center}, {@var text.align_left}."]},"order.ascending":{name:"order.ascending",type:"const bool",desc:[$.t("Determines the sort order of the array from the smallest to the largest value.",{context:"pine_docs_desc"})],seeAlso:["{@fun array.new_float}, {@fun array.sort}."]},"order.descending":{name:"order.descending",type:"const bool",desc:[$.t("Determines the sort order of the array from the largest to the smallest value.",{context:"pine_docs_desc"})],seeAlso:["{@fun array.new_float}, {@fun array.sort}."]},"alert.freq_all":{name:"alert.freq_all",type:"const string",desc:[$.t("A named constant for use with the `freq` parameter of the alert() function.",{context:"pine_docs_desc"}),$.t("All function calls trigger the alert.",{context:"pine_docs_desc"})],seeAlso:["{@fun alert}."]},"alert.freq_once_per_bar":{name:"alert.freq_once_per_bar",type:"const string",desc:[$.t("A named constant for use with the `freq` parameter of the alert() function.",{context:"pine_docs_desc"}),$.t("The first function call during the bar triggers the alert.",{context:"pine_docs_desc"})],seeAlso:["{@fun alert}."]},"alert.freq_once_per_bar_close":{name:"alert.freq_once_per_bar_close",type:"const string",desc:[$.t("A named constant for use with the `freq` parameter of the alert() function.",{context:"pine_docs_desc"}),$.t("The function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes.",{context:"pine_docs_desc"})],seeAlso:["{@fun alert}."]},"earnings.actual":{name:"earnings.actual",type:"const string",desc:[$.t("A named constant for the {@fun earnings} function. Is used to request the earnings value as it was reported.",{context:"pine_docs_desc"})],seeAlso:["{@fun earnings}."]},"earnings.estimate":{name:"earnings.estimate",type:"const string",desc:[$.t("A named constant for the {@fun earnings} function. Is used to request the estimated earnings value.",{context:"pine_docs_desc"})],seeAlso:["{@fun earnings}."]},"dividends.net":{name:"dividends.net",type:"const string",desc:[$.t("A named constant for the {@fun dividends} function. Is used to request the dividends return on a stock after deductions.",{context:"pine_docs_desc"})],seeAlso:["{@fun dividends}."]},"dividends.gross":{name:"dividends.gross",type:"const string",desc:[$.t("A named constant for the {@fun dividends} function. Is used to request the dividends return on a stock before deductions.",{context:"pine_docs_desc"})],seeAlso:["{@fun dividends}."]},"splits.denominator":{name:"splits.denominator",type:"const string",desc:[$.t("A named constant for the {@fun splits} function. Is used to request the denominator (the number below the line in a fraction) of a splits.",{context:"pine_docs_desc"})],seeAlso:["{@fun splits}."]},"splits.numerator":{name:"splits.numerator",type:"const string",desc:[$.t("A named constant for the {@fun splits} function. Is used to request the numerator (the number above the line in a fraction) of a splits.",{context:"pine_docs_desc"})],
seeAlso:["{@fun splits}."]},"color.black":{name:"color.black",type:"const color",desc:[$.t("Is a named constant for #363A45 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.silver":{name:"color.silver",type:"const color",desc:[$.t("Is a named constant for #B2B5BE color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.gray":{name:"color.gray",type:"const color",desc:[$.t("Is a named constant for #787B86 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.white":{name:"color.white",type:"const color",desc:[$.t("Is a named constant for #FFFFFF color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.maroon":{name:"color.maroon",type:"const color",desc:[$.t("Is a named constant for #880E4F color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.red":{name:"color.red",type:"const color",desc:[$.t("Is a named constant for #FF5252 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.purple":{name:"color.purple",type:"const color",desc:[$.t("Is a named constant for #9C27B0 color.",{context:"pine_docs_desc"})],
seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.fuchsia":{name:"color.fuchsia",type:"const color",desc:[$.t("Is a named constant for #E040FB color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.green":{name:"color.green",type:"const color",desc:[$.t("Is a named constant for #4CAF50 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.lime":{name:"color.lime",type:"const color",desc:[$.t("Is a named constant for #00E676 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.olive":{name:"color.olive",type:"const color",desc:[$.t("Is a named constant for #808000 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.yellow":{name:"color.yellow",type:"const color",desc:[$.t("Is a named constant for #FFEB3B color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.navy":{name:"color.navy",type:"const color",desc:[$.t("Is a named constant for #311B92 color.",{context:"pine_docs_desc"})],
seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.blue}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.blue":{name:"color.blue",type:"const color",desc:[$.t("Is a named constant for #2196F3 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.teal}, {@var color.aqua}, {@var color.orange}"]},"color.teal":{name:"color.teal",type:"const color",desc:[$.t("Is a named constant for #00897B color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.aqua}, {@var color.orange}"]},"color.aqua":{name:"color.aqua",type:"const color",desc:[$.t("Is a named constant for #00BCD4 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.orange}"]},"color.orange":{name:"color.orange",type:"const color",desc:[$.t("Is a named constant for #FF9800 color.",{context:"pine_docs_desc"})],seeAlso:["{@var color.black}, {@var color.silver}, {@var color.gray}, {@var color.white}, {@var color.maroon}, {@var color.red}, {@var color.purple}, {@var color.fuchsia}, {@var color.green}, {@var color.lime}, {@var color.olive}, {@var color.yellow}, {@var color.navy}, {@var color.blue}, {@var color.teal}, {@var color.aqua}"]}}},functions:{title:$.t("Built-in Functions"),prefix:"fun_",docs:{study:{kind:"Built-in annotation function",desc:[$.t("The function sets a number of study properties.",{context:"pine_docs_desc"})],args:[{name:"title",type:"const string",info:$.t("study title that would be seen in Indicators widget. Argument IS REQUIRED.",{context:"pine_docs_args_info"})},{name:"shorttitle",type:"const string",info:$.t("study short title that would be seen in the chart legend. Argument is optional.",{context:"pine_docs_args_info"})},{name:"overlay",type:"const bool",info:$.t("if true the study will be added as an overlay for the main series. If false - it would be added on a separate chart pane. Default is false.",{context:"pine_docs_args_info"})},{name:"format",type:"const string",
info:$.t("type of formatting study values on the price axis. Possible values are: {@var format.inherit}, {@var format.price}, {@var format.volume}. Default is {@var format.inherit}.",{context:"pine_docs_args_info"})},{name:"precision",type:"const integer",info:$.t("number of digits after the floating point for study values on the price axis. Must be a non negative integer and not greater than 16. If omitted, using formatting from parent series. If format is {@var format.inherit} and this argument is set, then format becomes {@var format.price}.",{context:"pine_docs_args_info"})},{name:"scale",type:"const integer",info:$.t("price scale that the indicator should be attached to. Possible values are: {@var scale.right}, {@var scale.left}, {@var scale.none}. Value {@var scale.none} can be applied only in combination with 'overlay=true' setting. If omitted, using scale from main series.",{context:"pine_docs_args_info"})},{name:"max_bars_back",type:"const integer",info:$.t("Maximum number of bars available for a study for historical reference. This parameter is applied to every built-in or user variable in the script if there is a reference to historical data of a variable in the script code (‘[]’ operator is used). Variable buffer sizes in the Pine Script are typically autodetected. This however is not possible in certain cases which is why the parameter allows a user to manually set the lower bound of this value. NOTE: using of the {@fun max_bars_back} function instead of the parameter is optimal because it applies to only one variable.",{context:"pine_docs_args_info"})},{name:"linktoseries",type:"const bool",info:$.t("if true then the study will be always on the same pane and same price scale as the main series. Should be used only in combination with 'overlay=true'. Default is false.",{context:"pine_docs_args_info"})},{name:"resolution",type:"const string",info:$.t("custom resolution of the study, which defines study input and behavior like a study body in the security context. If you specify the empty string resolution, it will appear the same as on the chart. Argument is optional.",{context:"pine_docs_args_info"})},{name:"max_lines_count",type:"const integer",info:$.t("The number of last line drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})},{name:"max_labels_count",type:"const integer",info:$.t("The number of last label drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})},{name:"resolution_gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var false}, {@var true}. {@var true} - requested data is merged with possible gaps. {@var false} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var true}.",{context:"pine_docs_args_info"})},{name:"max_boxes_count",type:"const integer",
info:$.t("The number of last box drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})}],remarks:[$.t("Every script must have one {@fun study} call.",{context:"pine_docs_remarks"}),$.t("Any function call with side effects will produce errors with the resolution param with any value",{context:"pine_docs_remarks"})],examples:["study(title='MyScriptStudy')",'study(title="MyScriptStudy", shorttitle="MSS", precision=6, overlay=true)'],seeAlso:["{@fun security}"],syntax:["study(title, shorttitle, overlay, format, precision, scale, max_bars_back, max_lines_count, max_labels_count, resolution, resolution_gaps, max_boxes_count) → void"]},plot:{kind:"Built-in annotation function",desc:[$.t("Plots a series of data on the chart.",{context:"pine_docs_desc"})],args:[{name:"series",type:"series",info:$.t("Series of data to be plotted. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plot.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"linewidth",type:"input integer",info:$.t("Width of the plotted line. Default value is 1. Not applicable to every style.",{context:"pine_docs_args_info"})},{name:"style",type:"input integer",info:$.t("Type of the plot. Possible values are: {@var plot.style_line}, {@var plot.style_stepline}, {@var plot.style_histogram}, {@var plot.style_cross}, {@var plot.style_area}, {@var plot.style_columns}, {@var plot.style_circles}. Default value is {@var plot.style_line}.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the plot. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"trackprice",type:"input bool",info:$.t("If true then a horizontal price line will be shown at the level of the last study value. Default is false.",{context:"pine_docs_args_info"})},{name:"histbase",type:"input float",info:$.t("The price value used as the reference level when rendering plot with {@var plot.style_histogram}, {@var plot.style_columns} or {@var plot.style_area} style. Default is 0.0.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts the plot to the left or to the right on the given number of bars. Default is 0.",{context:"pine_docs_args_info"})},{name:"join",type:"input bool",info:$.t("If true then plot points will be joined with line, applicable only to {@var plot.style_cross} and {@var plot.style_circles} styles. Default is false.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plot style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",
info:$.t("If set, defines the number of bars (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],returns:[$.t("A plot object, that can be used in {@fun fill}",{context:"pine_docs_returns"})],examples:["plot(high+low, title='Title', color=#00ffaa, linewidth=2, style=plot.style_area, transp=70, offset=15, trackprice=true)","","// You may fill the background between any two plots with a fill() function:","p1 = plot(open)","p2 = plot(close)","fill(p1, p2, color=color.green)"],seeAlso:["{@fun plotshape}, {@fun plotchar}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}, {@fun fill}"],syntax:["plot(series, title, color, linewidth, style, trackprice, transp, histbase, offset, join, editable, show_last, display) → plot"]},plotshape:{kind:"Built-in annotation function",desc:[$.t("Plots visual shapes on the chart.",{context:"pine_docs_desc"})],args:[{name:"series",type:"series",info:$.t("Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except {@var location.absolute}. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plot.",{context:"pine_docs_args_info"})},{name:"style",type:"input string",info:$.t("Type of the plot. Possible values are: {@var shape.xcross}, {@var shape.cross}, {@var shape.triangleup}, {@var shape.triangledown}, {@var shape.flag}, {@var shape.circle}, {@var shape.arrowup}, {@var shape.arrowdown}, {@var shape.labelup}, {@var shape.labeldown}, {@var shape.square}, {@var shape.diamond}. Default value is {@var shape.xcross}.",{context:"pine_docs_args_info"})},{name:"location",type:"input string",info:$.t("Location of shapes on the chart. Possible values are: {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}. Default value is {@var location.abovebar}.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the shapes. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts shapes to the left or to the right on the given number of bars. Default is 0.",{context:"pine_docs_args_info"})},{name:"text",type:"const string",info:$.t("Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'",{context:"pine_docs_args_info"})},{name:"textcolor",type:"color",
info:$.t("Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plotshape style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of shapes (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"size",type:"const string",info:$.t("Size of shapes on the chart. Possible values are: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default is {@var size.auto}.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],remarks:[$.t("Use {@fun plotshape} function in conjunction with 'overlay=true' {@fun study} parameter!",{context:"pine_docs_remarks"})],examples:["study('plotshape example 1', overlay=true)","data = close >= open","plotshape(data, style=shape.xcross)"],seeAlso:["{@fun plot}, {@fun plotchar}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}"],syntax:["plotshape(series, title, style, location, color, transp, offset, text, textcolor, editable, size, show_last, display) → void"]},plotchar:{kind:"Built-in annotation function",desc:[$.t("Plots visual shapes using any given one Unicode character on the chart.",{context:"pine_docs_desc"})],args:[{name:"series",type:"series",info:$.t("Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except {@var location.absolute}. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plot.",{context:"pine_docs_args_info"})},{name:"char",type:"input string",info:$.t("Character to use as a visual shape.",{context:"pine_docs_args_info"})},{name:"location",type:"input string",info:$.t("Location of shapes on the chart. Possible values are: {@var location.abovebar}, {@var location.belowbar}, {@var location.top}, {@var location.bottom}, {@var location.absolute}. Default value is {@var location.abovebar}.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the shapes. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts shapes to the left or to the right on the given number of bars. Default is 0.",{
context:"pine_docs_args_info"})},{name:"text",type:"const string",info:$.t("Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'",{context:"pine_docs_args_info"})},{name:"textcolor",type:"color",info:$.t("Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plotchar style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of chars (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"size",type:"const string",info:$.t("Size of characters on the chart. Possible values are: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default is {@var size.auto}.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],remarks:[$.t("Use {@fun plotchar} function in conjunction with 'overlay=true' {@fun study} parameter!",{context:"pine_docs_remarks"})],examples:["study('plotchar example', overlay=true)","data = close >= open","plotchar(data, char='❄')"],seeAlso:["{@fun plot}, {@fun plotshape}, {@fun plotarrow}, {@fun barcolor}, {@fun bgcolor}"],syntax:["plotchar(series, title, char, location, color, transp, offset, text, textcolor, editable, size, show_last, display) → void"]},plotarrow:{kind:"Built-in annotation function",desc:[$.t("Plots up and down arrows on the chart. Up arrow is drawn at every indicator positive value, down arrow is drawn at every negative value. If indicator returns {@var na} then no arrow is drawn. Arrows has different height, the more absolute indicator value the longer arrow is drawn.",{context:"pine_docs_desc"})],args:[{name:"series",type:"series",info:$.t("Series of data to be plotted as arrows. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plot.",{context:"pine_docs_args_info"})},{name:"colorup",type:"series[color]",info:$.t("Color of the up arrows. Optional argument.",{context:"pine_docs_args_info"})},{name:"colordown",type:"series[color]",info:$.t("Color of the down arrows. Optional argument.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the arrows. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts arrows to the left or to the right on the given number of bars. Default is 0.",{context:"pine_docs_args_info"})},{name:"minheight",type:"input integer",
info:$.t("Minimal possible arrow height in pixels. Default is 5.",{context:"pine_docs_args_info"})},{name:"maxheight",type:"input integer",info:$.t("Maximum possible arrow height in pixels. Default is 100.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plotarrow style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of arrows (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],remarks:[$.t("Use {@fun plotarrow} function in conjunction with 'overlay=true' {@fun study} parameter!",{context:"pine_docs_remarks"})],examples:['study("plotarrow example", overlay=true)',"codiff = close - open","plotarrow(codiff, colorup=color.teal, colordown=color.orange, transp=40)"],seeAlso:["{@fun plot}, {@fun plotshape}, {@fun plotchar}, {@fun barcolor}, {@fun bgcolor}"],syntax:["plotarrow(series, title, colorup, colordown, transp, offset, minheight, maxheight, editable, show_last, display) → void"]},plotbar:{kind:"Built-in annotation function",desc:[$.t("Plots ohlc bars on the chart.",{context:"pine_docs_desc"})],args:[{name:"open",type:"series",info:$.t("Open series of data to be used as open values of bars. Required argument.",{context:"pine_docs_args_info"})},{name:"high",type:"series",info:$.t("High series of data to be used as high values of bars. Required argument.",{context:"pine_docs_args_info"})},{name:"low",type:"series",info:$.t("Low series of data to be used as low values of bars. Required argument.",{context:"pine_docs_args_info"})},{name:"close",type:"series",info:$.t("Close series of data to be used as close values of bars. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plotbar. Optional argument.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the ohlc bars. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plotbar style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of bars (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],remarks:[$.t("Even if one value of open, high, low or close equal NaN then bar no draw.",{context:"pine_docs_remarks"
}),$.t("The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.",{context:"pine_docs_remarks"})],examples:["plotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)"],seeAlso:["{@fun plotcandle}"],syntax:["plotbar(open, high, low, close, title, color, editable, show_last, display) → void"]},plotcandle:{kind:"Built-in annotation function",desc:[$.t("Plots candles on the chart.",{context:"pine_docs_desc"})],args:[{name:"open",type:"series",info:$.t("Open series of data to be used as open values of candles. Required argument.",{context:"pine_docs_args_info"})},{name:"high",type:"series",info:$.t("High series of data to be used as high values of candles. Required argument.",{context:"pine_docs_args_info"})},{name:"low",type:"series",info:$.t("Low series of data to be used as low values of candles. Required argument.",{context:"pine_docs_args_info"})},{name:"close",type:"series",info:$.t("Close series of data to be used as close values of candles. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the plotcandles. Optional argument.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the candles. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"wickcolor",type:"series[color]",info:$.t("The color of the wick of candles. An optional argument.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then plotcandle style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of candles (from the last bar back to the past) to plot on chart.",{context:"pine_docs_args_info"})},{name:"bordercolor",type:"series[color]",info:$.t("The border color of candles. An optional argument.",{context:"pine_docs_args_info"})},{name:"display",type:"const integer",info:$.t("Controls where the plot is displayed. Possible values are: {@var display.none}, {@var display.all}. Default is {@var display.all}",{context:"pine_docs_args_info"})}],remarks:[$.t("Even if one value of open, high, low or close equal NaN then bar no draw.",{context:"pine_docs_remarks"}),$.t("The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'.",{context:"pine_docs_remarks"})],examples:["plotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)"],seeAlso:["{@fun plotbar}"],syntax:["plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display) → void"]},barcolor:{kind:"Built-in annotation function",desc:[$.t("Set color of bars.",{context:"pine_docs_desc"})],args:[{name:"color",type:"color",
info:$.t("Color of bars. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts the color series to the left or to the right on the given number of bars. Default is 0.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then barcolor style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of bars (from the last bar back to the past) to fill on chart.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the barcolor. Optional argument.",{context:"pine_docs_args_info"})}],examples:["barcolor(close < open ? color.black : color.white)"],seeAlso:["{@fun bgcolor}, {@fun plot}, {@fun fill}"],syntax:["barcolor(color, offset, editable, show_last, title) → void"]},bgcolor:{kind:"Built-in annotation function",desc:[$.t("Fill background of bars with specified color.",{context:"pine_docs_desc"})],args:[{name:"color",type:"color",info:$.t("Color of the filled background. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the filled background. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Shifts the color series to the left or to the right on the given number of bars. Default is 0.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then bgcolor style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of bars (from the last bar back to the past) to fill on chart.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the bgcolor. Optional argument.",{context:"pine_docs_args_info"})}],examples:["bgcolor(close < open ? color.red : color.green, transp=70)"],seeAlso:["{@fun barcolor}, {@fun plot}, {@fun fill}"],syntax:["bgcolor(color, transp, offset, editable, show_last, title) → void"]},"color.new":{kind:"Built-in function",desc:[$.t("Function color applies the specified transparency to the given color.",{context:"pine_docs_desc"})],returns:[$.t("Color with specified transparency.",{context:"pine_docs_returns"})],args:[{name:"color",type:"series[color]"},{name:"transp",type:"series[integer]",info:$.t("Possible values are from 0 (not transparent) to 100 (invisible).",{context:"pine_docs_args_info"})}],examples:["color.new(color.red, 50)"],remarks:[$.t('Color with transparency overrides "transp" argument of plot function.',{context:"pine_docs_remarks"})],syntax:["color.new(color, transp) → const color"]},
"color.rgb":{kind:"Built-in function",desc:[$.t("Creates a new color with transparency using the RGB color model.",{context:"pine_docs_desc"})],returns:[$.t("Color with specified transparency.",{context:"pine_docs_returns"})],args:[{name:"red",type:"series[float]",info:$.t("Red color component. Possible values are from 0 to 255.",{context:"pine_docs_args_info"})},{name:"green",type:"series[float]",info:$.t("Green color component. Possible values are from 0 to 255.",{context:"pine_docs_args_info"})},{name:"blue",type:"series[float]",info:$.t("Blue color component. Possible values are from 0 to 255.",{context:"pine_docs_args_info"})},{name:"transp",type:"series[float]",info:$.t("Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.",{context:"pine_docs_args_info"})}],examples:["color.rgb(255, 0, 0, 50)"],remarks:[$.t('When specified, the "transp" argument overrides the "transp" argument used in other functions.',{context:"pine_docs_remarks"})],syntax:["color.rgb(red, green, blue, transp) → series[color]","color.rgb(red, green, blue, transp) → const color","color.rgb(red, green, blue, transp) → input color"]},"color.r":{kind:"Built-in function",desc:[$.t("Retrieves the value of the color's red component.",{context:"pine_docs_desc"})],returns:[$.t("The value (0 to 255) of the color's red component.",{context:"pine_docs_returns"})],args:[{name:"color",type:"series[color]",info:$.t("Color.",{context:"pine_docs_args_info"})}],examples:["color.r(color.red)"],syntax:["color.r(color) → series[float]","color.r(color) → const float","color.r(color) → input float"]},"color.g":{kind:"Built-in function",desc:[$.t("Retrieves the value of the color's green component.",{context:"pine_docs_desc"})],returns:[$.t("The value (0 to 255) of the color's green component.",{context:"pine_docs_returns"})],args:[{name:"color",type:"series[color]",info:$.t("Color.",{context:"pine_docs_args_info"})}],examples:["color.g(color.green)"],syntax:["color.g(color) → series[float]","color.g(color) → const float","color.g(color) → input float"]},"color.b":{kind:"Built-in function",desc:[$.t("Retrieves the value of the color's blue component.",{context:"pine_docs_desc"})],returns:[$.t("The value (0 to 255) of the color's blue component.",{context:"pine_docs_returns"})],args:[{name:"color",type:"series[color]",info:$.t("Color.",{context:"pine_docs_args_info"})}],examples:["color.b(color.blue)"],syntax:["color.b(color) → series[float]","color.b(color) → const float","color.b(color) → input float"]},"color.t":{kind:"Built-in function",desc:[$.t("Retrieves the color's transparency.",{context:"pine_docs_desc"})],returns:[$.t("The value (0-100) of the color's transparency.",{context:"pine_docs_returns"})],args:[{name:"color",type:"series[color]",info:$.t("Color.",{context:"pine_docs_args_info"})}],examples:["color.t(color.new(color.red, 50))"],syntax:["color.t(color) → series[float]","color.t(color) → const float","color.t(color) → input float"]},"color.from_gradient":{kind:"Built-in function",
desc:[$.t("Based on the relative position of value in the bottom_value to top_value range, the function returns a color from the gradient defined by bottom_color to top_color.",{context:"pine_docs_desc"})],returns:[$.t("A color calculated from the linear gradient between bottom_color to top_color.",{context:"pine_docs_returns"})],args:[{name:"value",type:"series[float]",info:$.t("Value to calculate the position-dependent color.",{context:"pine_docs_args_info"})},{name:"bottom_value",type:"series[float]",info:$.t("Bottom position value corresponding to bottom_color.",{context:"pine_docs_args_info"})},{name:"top_value",type:"series[float]",info:$.t("Top position value corresponding to top_color.",{context:"pine_docs_args_info"})},{name:"bottom_color",type:"series[color]",info:$.t("Bottom position color.",{context:"pine_docs_args_info"})},{name:"top_color",type:"series[color]",info:$.t("Top position color.",{context:"pine_docs_args_info"})}],examples:["color1 = color.from_gradient(close, high, low, color.yellow, color.lime)","color2 = color.from_gradient(rsi(close,7), 0, 100, color.rgb(255, 0, 0), color.rbg(0, 255, 0, 50))","plot(close, color=color1)","plot(rsi(close,7), color=color2)"],syntax:["color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series[color]"]},alertcondition:{kind:"Built-in annotation function",desc:[$.t("Creates alert condition, that is available in Create Alert dialog. Please note, that {@fun alertcondition} does NOT create an alert, it just gives you more options in Create Alert dialog. Also, {@fun alertcondition} effect is invisible on chart.",{context:"pine_docs_desc"})],args:[{name:"condition",type:"series",info:$.t("Series of boolean values that is used for alert. True values mean alert fire, false - no alert. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the alert condition. Optional argument.",{context:"pine_docs_args_info"})},{name:"message",type:"const string",info:$.t("Message to display when alert fires. Optional argument.",{context:"pine_docs_args_info"})}],examples:["alertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')"],remarks:[$.t("Please note that in Pine v4 an alertcondition call generates an additional plot. All such calls are taken into account when we calculate the number of the output series per script.",{context:"pine_docs_remarks"})],seeAlso:["{@fun alert}"],syntax:["alertcondition(condition, title, message) → void"]},input:{kind:"Built-in annotation function",desc:[$.t("Adds an input to your script indicator. User can see and edit inputs on the Format Object dialog of the script study. Script inputs look and behave exactly the same as inputs of built-in Technical Analysis indicators.",{context:"pine_docs_desc"})],returns:[$.t("Value of input variable.",{context:"pine_docs_returns"})],args:[{name:"defval",type:"Its type must match the type defined with the 'type' parameter's value",
info:$.t('Determines the default value of the input variable proposed in the script\'s "Settings/Inputs" tab, from where the user can change it. When used with the {@var input.time} type, the value can be a {@fun timestamp} function, but only if it uses a date argument in const string format.',{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string",{context:"pine_docs_args_info"})},{name:"type",type:"const string",info:$.t("Input type. Possible values are {@var input.bool}, {@var input.integer}, {@var input.float}, {@var input.string}, {@var input.symbol}, {@var input.resolution}, {@var input.session}, {@var input.source}, {@var input.color}, {@var input.time}.",{context:"pine_docs_args_info"})},{name:"minval",type:"const integer, float",info:$.t("Minimal possible value of the input variable. This argument is used only when input type is {@var input.integer} or {@var input.float}.",{context:"pine_docs_args_info"})},{name:"maxval",type:"const integer, float",info:$.t("Maximum possible value of the input variable. This argument is used only when input type is {@var input.integer} or {@var input.float}.",{context:"pine_docs_args_info"})},{name:"confirm",type:"const bool",info:$.t("If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false. This argument not used when input type is {@var input.source}.",{context:"pine_docs_args_info"})},{name:"step",type:"const integer, float",info:$.t("Step value to use for incrementing/decrementing input from format dialog. Default value is 1. This argument is used only for input types {@var input.integer} and {@var input.float}.",{context:"pine_docs_args_info"})},{name:"options",type:"List of constants: [<type>...]",info:$.t("A list of options to choose from. This argument is used only for input types {@var input.integer}, {@var input.float} and {@var input.string}.",{context:"pine_docs_args_info"})},{name:"tooltip",type:"const string",info:$.t("The string that will be shown to the user when hovering over the tooltip icon.",{context:"pine_docs_args_info"})},{name:"inline",type:"const string",info:$.t("Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",{context:"pine_docs_args_info"})},{name:"group",type:"const string",info:$.t("Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",{context:"pine_docs_args_info"})}],remarks:[$.t("Result of {@fun input} function always should be assigned to a variable, see examples above.",{context:"pine_docs_remarks"})],
examples:['b = input(title="On/Off", type=input.bool, defval=true)',"plot(b ? open : na)","",'i = input(title="Offset", type=input.integer, defval=7, minval=-10, maxval=10)',"plot(offset(close, i))","",'f = input(title="Angle", type=input.float, defval=-0.5, minval=-3.14, maxval=3.14, step=0.02)',"plot(sin(f) > 0 ? close : open)","",'sym = input(title="Symbol", type=input.symbol, defval="DELL")','res = input(title="Resolution", type=input.resolution, defval="60")','c = input(title="Plot Color", type=input.color, defval=color.red)',"plot(close, color=c)","plot(security(sym, res, close), color=color.green)","",'s = input(title="Session", defval="24x7", options=["24x7", "0900-1300", "1300-1700", "1700-2100"])',"plot(time(timeframe.period, s))","",'src = input(title="Source", type=input.source, defval=close)',"plot(src)","",'date1 = input(title="Date", type=input.time, defval=timestamp("20 Feb 2020 00:00 +0300"))',"plot(date1)","",'date2 = input(title="Date", type=input.time, defval=timestamp("2020-02-20T00:00+03:00"))',"plot(date2)"],syntax:["input(defval, title, type, confirm, tooltip, inline, group) → input bool","input(defval, title, type, confirm, inline, group) → input color","input(defval, title, type, minval, maxval, confirm, step, options, tooltip, inline, group) → input integer","input(defval, title, type, minval, maxval, confirm, step, options, tooltip, inline, group) → input float","input(defval, title, type, confirm, options, tooltip, inline, group) → input string","input(defval, title, type, tooltip, inline, group) → series[float]"]},hline:{kind:"Built-in annotation function",desc:[$.t("Renders a horizontal line at a given fixed price level.",{context:"pine_docs_desc"})],args:[{name:"price",type:"input float",info:$.t("Price value at which the object will be rendered. Required argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the object.",{context:"pine_docs_args_info"})},{name:"color",type:"input color",info:$.t("Color of the rendered line. Must be a constant value (not an expression). Optional argument.",{context:"pine_docs_args_info"})},{name:"linestyle",type:"input integer",info:$.t("Style of the rendered line. Possible values are: {@var hline.style_solid}, {@var hline.style_dotted}, {@var hline.style_dashed}. Optional argument.",{context:"pine_docs_args_info"})},{name:"linewidth",type:"input integer",info:$.t("Width of the rendered line. Default value is 1. ",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then hline style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})}],returns:[$.t("An hline object, that can be used in {@fun fill}",{context:"pine_docs_returns"})],examples:["hline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)","","// You may fill the background between any two hlines with a fill() function:","h1 = hline(20)","h2 = hline(10)","fill(h1, h2)"],seeAlso:["{@fun fill}"],
syntax:["hline(price, title, color, linestyle, linewidth, editable) → hline"]},fill:{kind:"Built-in annotation function",desc:[$.t("Fills background between two plots or hlines with a given color.",{context:"pine_docs_desc"})],args:[{name:"hline1",type:"hline",info:$.t("The first hline object. Required argument.",{context:"pine_docs_args_info"})},{name:"hline2",type:"hline",info:$.t("The second hline object. Required argument.",{context:"pine_docs_args_info"})},{name:"plot1",type:"plot",info:$.t("The first plot object. Required argument.",{context:"pine_docs_args_info"})},{name:"plot2",type:"plot",info:$.t("The second plot object. Required argument.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",{context:"pine_docs_args_info"})},{name:"transp",type:"input integer",info:$.t("Transparency of the filled background. Possible values are from 0 (not transparent) to 100 (invisible). Optional argument.",{context:"pine_docs_args_info"})},{name:"title",type:"const string",info:$.t("Title of the created fill object. Optional argument.",{context:"pine_docs_args_info"})},{name:"editable",type:"const bool",info:$.t("If true then fill style will be editable in Format dialog. Default is true.",{context:"pine_docs_args_info"})},{name:"show_last",type:"input integer",info:$.t("If set, defines the number of bars (from the last bar back to the past) to fill on chart.",{context:"pine_docs_args_info"})},{name:"fillgaps",type:"const bool",info:$.t("Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value. When true, the last fill will continue on gaps. The default is false.",{context:"pine_docs_args_info"})}],examples:["h1 = hline(20)","h2 = hline(10)","fill(h1, h2)","","p1 = plot(open)","p2 = plot(close)","fill(p1, p2, color=color.green)"],seeAlso:["{@fun plot}, {@fun barcolor}, {@fun bgcolor}, {@fun hline}"],syntax:["fill(hline1, hline2, color, transp, title, editable, fillgaps) → void","fill(plot1, plot2, color, transp, title, editable, show_last, fillgaps) → void"]},nz:{kind:"Built-in function",desc:[$.t("Replaces NaN values with zeros (or given value) in a series.",{context:"pine_docs_desc"})],returns:[$.t("Two args version: returns x if it's a valid (not NaN) number, otherwise y",{context:"pine_docs_returns"}),$.t("One arg version: returns x if it's a valid (not NaN) number, otherwise 0",{context:"pine_docs_returns"})],args:[{name:"x",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"y",type:"float",info:$.t("Value that will be inserted instead of all NaN values in x series.",{context:"pine_docs_args_info"})}],examples:["nz(sma(close, 100))"],seeAlso:["{@var na} (variable), {@fun na}, {@fun fixnan}"],
syntax:["nz(x, y) → integer","nz(x, y) → float","nz(x, y) → color","nz(x, y) → bool","nz(x, y) → series[integer]","nz(x, y) → series[float]","nz(x, y) → series[color]","nz(x, y) → series[bool]","nz(x) → integer","nz(x) → float","nz(x) → color","nz(x) → bool","nz(x) → series[integer]","nz(x) → series[float]","nz(x) → series[color]","nz(x) → series[bool]"]},na:{kind:"Built-in function",desc:[$.t("Test value if it's a NaN.",{context:"pine_docs_desc"})],returns:[$.t("true if x is not a valid number (x is NaN), otherwise false.",{context:"pine_docs_returns"})],seeAlso:["{@var na} (variable), {@fun fixnan}, {@fun nz}"],syntax:["na(x) → bool","na(x) → series[bool]"]},tr:{kind:"Built-in function",returns:[$.t("True range. It is max(high - low, abs(high - close[1]), abs(low - close[1]))",{context:"pine_docs_returns"})],args:[{name:"handle_na",type:"bool",info:$.t("How NaN values are handled. if true, and previous day's close is NaN then tr would be calculated as current day high-low. Otherwise (if false) tr would return NaN in such cases. Also note, that {@fun atr} uses tr(true).",{context:"pine_docs_args_info"})}],remarks:[$.t("tr(false) is exactly the same as {@var tr}.",{context:"pine_docs_remarks"})],seeAlso:["{@var tr} (variable), {@fun atr}"],syntax:["tr(handle_na) → series[float]"]},pow:{kind:"Built-in function",desc:[$.t("Mathematical power function.",{context:"pine_docs_desc"})],returns:[$.t("x raised to the power of y. If x is a series, it is calculated elementwise.",{context:"pine_docs_returns"})],args:[{name:"base",info:$.t("Specify the base to use.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"exponent",type:"float",info:$.t("Specifies the exponent.",{context:"pine_docs_args_info"})}],examples:["pow(close, 2)"],seeAlso:["{@fun sqrt}, {@fun exp}"],syntax:["pow(base, exponent) → float","pow(base, exponent) → input float","pow(base, exponent) → const float","pow(base, exponent) → series[float]"]},min:{desc:[$.t("Returns the smallest of multiple values",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The smallest of multiple given values.",{context:"pine_docs_returns"})],seeAlso:["{@fun max}"],examples:["min(close, open)","min(close, min(open, 42))"],syntax:["min(x1, x2, ...) -> const integer","min(x1, x2, ...) -> input integer","min(x1, x2, ...) -> integer","min(x1, x2, ...) -> series[integer]","min(x1, x2, ...) -> const float","min(x1, x2, ...) -> input float","min(x1, x2, ...) -> float","min(x1, x2, ...) -> series[float]"]},max:{kind:"Built-in function",desc:[$.t("Returns the greatest of multiple values",{context:"pine_docs_desc"})],syntax:["max(x1, x2, ...) -> const integer","max(x1, x2, ...) -> input integer","max(x1, x2, ...) -> integer","max(x1, x2, ...) -> series[integer]","max(x1, x2, ...) -> const float","max(x1, x2, ...) -> input float","max(x1, x2, ...) -> float","max(x1, x2, ...) -> series[float]"],returns:[$.t("The greatest of multiple given values.",{context:"pine_docs_returns"})],seeAlso:["{@fun min}"],examples:["max(close, open)","max(close, max(open, 42))"]},
"str.format":{kind:"Built-in function",desc:[$.t("Converts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list.",{context:"pine_docs_desc"})],args:[{name:"formatString",type:"series[string]",info:$.t("Format string.",{context:"pine_docs_args_info"})},{name:"arg0, arg1, ...",type:"const integer, float, string, bool, na, series[integer], series[float], series[string], series[bool], series[na], array[series[integer]], array[series[float]], array[series[string]], array[series[bool]]",info:$.t("Values to format.",{context:"pine_docs_args_info"})}],syntax:["str.format(formatString, arg0, arg1, ...) -> string","str.format(formatString, arg0, arg1, ...) -> series[string]"],remarks:[$.t('Any curly braces within an unquoted pattern must be balanced. For example, "ab {0} de" and "ab \'}\' de" are valid patterns, but "ab {0\'}\' de", "ab } de" and "\'\'{\'\'" are not.',{context:"pine_docs_remarks"})],returns:[$.t("The formatted string.",{context:"pine_docs_returns"})],examples:["// The format specifier inside the curly braces accepts certain modifiers:","// - Specify the number of decimals to display:",'str.format("{0,number,#.#}", 1.34) // returns: 1.3',"// - Round a float value to an integer:",'str.format("{0,number,integer}", 1.34) // returns: 1',"// - Display a number in currency:",'str.format("{0,number,currency}", 1.34) // returns: $1.34',"// - Display a number as a percentage:",'str.format("{0,number,percent}", 0.5) // returns: 50%',"// EXAMPLES WITH SEVERAL ARGUMENTS","// returns: Number 1 is not equal to 4",'str.format("Number {0} is not {1} to {2}", 1, "equal", 4)',"// returns: 1.34 != 1.3",'str.format("{0} != {0, number, #.#}", 1.34)',"// returns: 1 is equal to 1, but 2 is equal to 2",'str.format("{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2", 1.34, 1.52)',"// returns: The cash turnover amounted to $1,340,000.00",'str.format("The cash turnover amounted to {0, number, currency}", 1340000)',"// returns: Expected return is 10% - 20%",'str.format("Expected return is {0, number, percent} - {1, number, percent}", 0.1, 0.2)']},abs:{desc:[$.t("Absolute value of x is x if x >= 0, or -x otherwise.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The absolute value of x",{context:"pine_docs_returns"})],syntax:["abs(x) → integer","abs(x) → input integer","abs(x) → const integer","abs(x) → series[integer]","abs(x) → float","abs(x) → input float","abs(x) → const float","abs(x) → series[float]"]},log:{desc:[$.t("Natural logarithm of any x > 0 is the unique `y` such that e^y = x",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The natural logarithm of x.",{context:"pine_docs_returns"})],seeAlso:["{@fun log10}"],
syntax:["log(x) → float","log(x) → input float","log(x) → const float","log(x) → series[float]"]},log10:{desc:[$.t("Base 10 logarithm of any x > 0 is the unique `y` such that 10^y = x",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The base 10 logarithm of x.",{context:"pine_docs_returns"})],seeAlso:["{@fun log}"],syntax:["log10(x) → float","log10(x) → input float","log10(x) → const float","log10(x) → series[float]"]},sqrt:{desc:[$.t("Square root of any x >= 0 is the unique y >= 0 such that y^2 = x",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The square root of x.",{context:"pine_docs_returns"})],seeAlso:["{@fun pow}"],syntax:["sqrt(x) → float","sqrt(x) → input float","sqrt(x) → const float","sqrt(x) → series[float]"]},sign:{desc:[$.t("Sign (signum) of x is zero if the x is zero, 1.0 if the x is greater than zero, -1.0 if the x is less than zero.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The sign of the argument.",{context:"pine_docs_returns"})],syntax:["sign(x) → float","sign(x) → input float","sign(x) → const float","sign(x) → series[float]"]},exp:{desc:[$.t("The exp function of x is e^x, where x is the argument and e is Euler's number.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("A number representing e^x.",{context:"pine_docs_returns"})],seeAlso:["{@fun pow}"],syntax:["exp(x) → float","exp(x) → input float","exp(x) → const float","exp(x) → series[float]"]},sin:{desc:[$.t("The sin function returns the trigonometric sine of an angle.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The trigonometric sine of an angle.",{context:"pine_docs_returns"})],args:[{name:"x",info:$.t("Angle, in radians.",{context:"pine_docs_args_info"}),type:"series[float]"}],syntax:["sin(x) → float","sin(x) → input float","sin(x) → const float","sin(x) → series[float]"]},cos:{desc:[$.t("The cos function returns the trigonometric cosine of an angle.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The trigonometric cosine of an angle.",{context:"pine_docs_returns"})],args:[{name:"x",info:$.t("Angle, in radians.",{context:"pine_docs_args_info"}),type:"series[float]"}],syntax:["cos(x) → float","cos(x) → input float","cos(x) → const float","cos(x) → series[float]"]},tan:{desc:[$.t("The tan function returns the trigonometric tangent of an angle.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The trigonometric tangent of an angle.",{context:"pine_docs_returns"})],args:[{name:"x",info:$.t("Angle, in radians.",{context:"pine_docs_args_info"}),type:"series[float]"}],syntax:["tan(x) → float","tan(x) → input float","tan(x) → const float","tan(x) → series[float]"]},asin:{desc:[$.t("The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1].",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or {@var na} if y is outside of range [-1, 1].",{
context:"pine_docs_returns"})],syntax:["asin(x) → float","asin(x) → input float","asin(x) → const float","asin(x) → series[float]"]},acos:{desc:[$.t("The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1].",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The arc cosine of a value; the returned angle is in the range [0, Pi], or {@var na} if y is outside of range [-1, 1].",{context:"pine_docs_returns"})],syntax:["acos(x) → float","acos(x) → input float","acos(x) → const float","acos(x) → series[float]"]},atan:{desc:[$.t("The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2].",{context:"pine_docs_returns"})],syntax:["atan(x) → float","atan(x) → input float","atan(x) → const float","atan(x) → series[float]"]},ceil:{desc:[$.t("The ceil function returns the smallest (closest to negative infinity) integer that is greater than or equal to the argument.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The smallest integer greater than or equal to the given number.",{context:"pine_docs_returns"})],seeAlso:["{@fun floor}, {@fun round}"],syntax:["ceil(x) → integer","ceil(x) → input integer","ceil(x) → const integer","ceil(x) → series[integer]"]},floor:{kind:"Built-in function",returns:[$.t("The largest integer less than or equal to the given number.",{context:"pine_docs_returns"})],seeAlso:["{@fun ceil}, {@fun round}"],syntax:["floor(x) → integer","floor(x) → input integer","floor(x) → const integer","floor(x) → series[integer]"]},round:{desc:[$.t("Returns the value of x rounded to the nearest integer, with ties rounding up. If the precision parameter is used, returns a float value rounded to that number of decimal places.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of x rounded to the nearest integer, or according to precision.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series",info:$.t("The value to be rounded.",{context:"pine_docs_args_info"})},{name:"precision",type:"integer",info:$.t("Optional argument. Decimal places to which x will be rounded. When no argument is supplied, rounding is to the nearest integer.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun ceil}, {@fun floor}"],syntax:["round(x) → integer","round(x) → input integer","round(x) → const integer","round(x) → series[integer]","round(number, precision) → float","round(number, precision) → input float","round(number, precision) → const float","round(number, precision) → series[float]"]},round_to_mintick:{kind:"Built-in function",desc:[$.t("Returns the value rounded to the symbol's mintick, i.e. the nearest value that can be divided by {@var syminfo.mintick}, without the remainder, with ties rounding up.",{context:"pine_docs_desc"})],returns:[$.t("The value of x rounded to the mintick.",{context:"pine_docs_returns"})],args:[{
name:"x",type:"series[float]",info:$.t("The value to be rounded.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun ceil}, {@fun floor}"],syntax:["round_to_mintick(x) → float","round_to_mintick(x) → series[float]"]},median:{desc:[$.t("Returns the median of the series.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The median of the series.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"series[integer]",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})}],syntax:["median(source, length) → series[float]","median(source, length) → series[integer]"]},mode:{desc:[$.t("Returns the {html_markup_1}mode{html_markup_2} of the series. If there are several values with the same frequency, it returns the smallest value.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://en.wikipedia.org/wiki/Mode_(statistics)">',html_markup_2:"</a>"})],kind:"Built-in function",returns:[$.t("The mode of the series.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"series[integer]",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})}],syntax:["mode(source, length) → series[float]","mode(source, length) → series[integer]"]},range:{desc:[$.t("Returns the difference between the min and max values in a series.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The difference between the min and max values in the series.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"series[integer]",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})}],syntax:["range(source, length) → series[float]","range(source, length) → series[integer]"]},todegrees:{desc:[$.t("Returns an approximately equivalent angle in degrees from an angle measured in radians.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The angle value in degrees. ",{context:"pine_docs_returns"})],args:[{name:"radians",type:"series",info:$.t("Angle in radians.",{context:"pine_docs_args_info"})}],syntax:["todegrees(radians) → series[float]"]},toradians:{desc:[$.t("Returns an approximately equivalent angle in radians from an angle measured in degrees.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The angle value in radians.",{context:"pine_docs_returns"})],args:[{name:"degrees",type:"series",info:$.t("Angle in degrees.",{context:"pine_docs_args_info"})}],syntax:["toradians(degrees) → series[float]"]},random:{desc:[$.t("Returns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence.",{context:"pine_docs_desc"})],kind:"Built-in function",
returns:[$.t("A positive random value.",{context:"pine_docs_returns"})],args:[{name:"min",type:"series[float]",info:$.t("The lower bound of the range of random values. The value is not included in the range. The default is 0.",{context:"pine_docs_args_info"})},{name:"max",type:"series[float]",info:$.t("The upper bound of the range of random values. The value is not included in the range. The default is 1.",{context:"pine_docs_args_info"})},{name:"seed",type:"input integer",info:$.t("Optional argument. When the same seed is used, allows successive calls to the function to produce a repeatable set of values.",{context:"pine_docs_args_info"})}],syntax:["random(min, max, seed) → series[float]"]},sum:{desc:[$.t("The sum function returns the sliding sum of last y values of x.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Sum of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length). Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun cum}","{@op for}"],syntax:["sum(source, length) → series[float]"]},sma:{desc:[$.t("The sma function returns the moving average, that is the sum of last y values of x, divided by y.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Simple moving average of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length). Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["plot(sma(close, 15))","","// same on pine, but much less efficient","pine_sma(x, y) =>","    sum = 0.0","    for i = 0 to y - 1","        sum := sum + x[i] / y","    sum","plot(pine_sma(close, 15))"],seeAlso:["{@fun ema}, {@fun rma}, {@fun wma}, {@fun vwma}, {@fun swma}, {@fun alma}"],syntax:["sma(source, length) → series[float]"]},hma:{desc:[$.t("The hma function returns the Hull Moving Average.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Hull moving average of 'source' for 'length' bars back.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"integer",info:$.t("Number of bars.",{context:"pine_docs_args_info"})}],examples:['study("Hull Moving Average")','src = input(defval=close, type=input.source, title="Source")','length = input(defval=9, type=input.integer, title="Length")',"hmaBuildIn = hma(src, length)",'plot(hmaBuildIn, title="Hull MA", color=#674EA7)'],seeAlso:["{@fun ema}, {@fun rma}, {@fun wma}, {@fun vwma}, {@fun sma}"],syntax:["hma(source, length) → series[float]"]},ema:{
desc:[$.t("The ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: EMA = alpha * x + (1 - alpha) * EMA[1], where alpha = 2 / (y + 1)",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Exponential moving average of x with alpha = 2 / (y + 1)",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"integer",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})}],remarks:[$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})],examples:["plot(ema(close, 15))","","//the same on pine","pine_ema(src, length) =>","    alpha = 2 / (length + 1)","    sum = 0.0","    sum := na(sum[1]) ? sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])","plot(pine_ema(close,15))"],seeAlso:["{@fun sma}, {@fun rma}, {@fun wma}, {@fun vwma}, {@fun swma}, {@fun alma}"],syntax:["ema(source, length) → series[float]"]},wma:{desc:[$.t("The wma function returns weighted moving average of x for y bars back. In wma weighting factors decrease in arithmetical progression.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Weighted moving average of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length). Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["plot(wma(close, 15))","","// same on pine, but much less efficient","pine_wma(x, y) =>","    norm = 0.0","    sum = 0.0","    for i = 0 to y - 1","        weight = (y - i) * y","        norm := norm + weight","        sum := sum + x[i] * weight","    sum / norm","plot(pine_wma(close, 15))"],seeAlso:["{@fun sma}, {@fun ema}, {@fun rma}, {@fun vwma}, {@fun swma}, {@fun alma}"],syntax:["wma(source, length) → series[float]"]},vwma:{kind:"Built-in function",desc:[$.t("The vwma function returns volume-weighted moving average of x for y bars back. It is the same as: sma(x * volume, y) / sma(volume, y)",{context:"pine_docs_desc"})],returns:[$.t("Volume-weighted moving average of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length). Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["plot(vwma(close, 15))","","// same on pine, but less efficient","pine_vwma(x, y) =>","    sma(x * volume, y) / sma(volume, y)","plot(pine_vwma(close, 15))"],
seeAlso:["{@fun sma}, {@fun ema}, {@fun rma}, {@fun wma}, {@fun swma}, {@fun alma}"],syntax:["vwma(source, length) → series[float]"]},supertrend:{kind:"Built-in function",desc:[$.t("The Supertrend Indicator. The Supertrend is a trend following indicator.",{context:"pine_docs_desc"})],returns:[$.t("Tuple of two supertrend series: supertrend line and direction of trend. Possible values are 1 (up direction) and -1 (down direction).",{context:"pine_docs_returns"})],args:[{name:"factor",type:"series",info:$.t("The multiplier by which the ATR will get multiplied.",{context:"pine_docs_args_info"})},{name:"atrPeriod",type:"integer",info:$.t("Length of ATR.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("Supertrend", overlay=true)',"mult = input(type=input.float, defval=4)","len = input(type=input.integer, defval=14)","[superTrend, dir] = supertrend(mult, len)","colResistance = dir == 1 and dir == dir[1] ? color.new(color.red, 0) : color.new(color.red, 100)","colSupport = dir == -1 and dir == dir[1] ? color.new(color.green, 0) : color.new(color.green, 100)","plot(superTrend, color = colResistance, linewidth=2)","plot(superTrend, color = colSupport, linewidth=2)"],seeAlso:["{@fun macd}"],syntax:["supertrend(factor, atrPeriod) → [series[float], series[float]]"]},macd:{kind:"Built-in function",desc:[$.t("MACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock's price.",{context:"pine_docs_desc"})],returns:[$.t("Tuple of three MACD series: MACD line, signal line and histogram line.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"fastlen",type:"integer",info:$.t("Fast Length parameter.",{context:"pine_docs_args_info"})},{name:"slowlen",type:"integer",info:$.t("Slow Length parameter.",{context:"pine_docs_args_info"})},{name:"siglen",type:"integer",info:$.t("Signal Length parameter.",{context:"pine_docs_args_info"})}],examples:["// Example 1","study('MACD')","[macdLine, signalLine, histLine] = macd(close, 12, 26, 9)","plot(macdLine, color=color.blue)","plot(signalLine, color=color.orange)","plot(histLine, color=color.red, style=plot.style_histogram)","","// Example 2","// If you need only one value, use placeholders '_' like this:","study('MACD')","[_, signalLine, _] = macd(close, 12, 26, 9)","plot(signalLine, color=color.orange)"],seeAlso:["{@fun sma}, {@fun ema}"],syntax:["macd(source, fastlen, slowlen, siglen) → [series[float], series[float], series[float]]"]},lowest:{kind:"Built-in function",desc:[$.t("Lowest value for a given number of bars back.",{context:"pine_docs_desc"})],returns:[$.t("Lowest value.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series[float]"},{name:"length",type:"series[integer]"}],remarks:[$.t("Two args version: x is a series and y is a length.",{context:"pine_docs_remarks"}),$.t("One arg version: x is a length. Algorithm uses low as a source series.",{
context:"pine_docs_remarks"})],seeAlso:["{@fun highest}, {@fun lowestbars}, {@fun highestbars}, {@fun valuewhen}, {@fun barssince}"],syntax:["lowest(source, length) → series[float]","lowest(length) → series[float]"]},highest:{kind:"Built-in function",desc:[$.t("Highest value for a given number of bars back.",{context:"pine_docs_desc"})],returns:[$.t("Highest value.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series[float]"},{name:"length",type:"series[integer]"}],remarks:[$.t("Two args version: x is a series and y is a length.",{context:"pine_docs_remarks"}),$.t("One arg version: x is a length. Algorithm uses high as a source series.",{context:"pine_docs_remarks"})],seeAlso:["{@fun lowest}, {@fun lowestbars}, {@fun highestbars}, {@fun valuewhen}, {@fun barssince}"],syntax:["highest(source, length) → series[float]","highest(length) → series[float]"]},lowestbars:{kind:"Built-in function",desc:[$.t("Lowest value offset for a given number of bars back.",{context:"pine_docs_desc"})],returns:[$.t("Offset to the lowest bar.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series[float]"},{name:"length",type:"series[integer]"}],remarks:[$.t("Two args version: x is a series and y is a length.",{context:"pine_docs_remarks"}),$.t("One arg version: x is a length. Algorithm uses low as a source series.",{context:"pine_docs_remarks"})],seeAlso:["{@fun lowest}, {@fun highest}, {@fun highestbars}, {@fun barssince}, {@fun valuewhen}"],syntax:["lowestbars(source, length) → series[integer]","lowestbars(length) → series[integer]"]},highestbars:{kind:"Built-in function",desc:[$.t("Highest value offset for a given number of bars back.",{context:"pine_docs_desc"})],returns:[$.t("Offset to the highest bar.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series[float]"},{name:"length",type:"series[integer]"}],remarks:[$.t("Two args version: x is a series and y is a length.",{context:"pine_docs_remarks"}),$.t("One arg version: x is a length. Algorithm uses high as a source series.",{context:"pine_docs_remarks"})],seeAlso:["{@fun lowest}, {@fun highest}, {@fun lowestbars}, {@fun barssince}, {@fun valuewhen}"],syntax:["highestbars(source, length) → series[integer]","highestbars(length) → series[integer]"]},barssince:{kind:"Built-in function",desc:[$.t("Counts the number of bars since the last time the condition was true.",{context:"pine_docs_desc"})],returns:[$.t("Number of bars since condition was true.",{context:"pine_docs_returns"})],remarks:[$.t("If the condition has never been met prior to the current bar, the function returns na.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})],examples:["// get number of bars since last color.green bar","barssince(close >= open)"],
seeAlso:["{@fun lowestbars}, {@fun highestbars}, {@fun valuewhen}, {@fun highest}, {@fun lowest}"],syntax:["barssince(condition) → series[integer]"]},valuewhen:{kind:"Built-in function",desc:[$.t("Source series value when the condition was true on the n-th most recent occurrence.",{context:"pine_docs_desc"})],returns:[$.t("Source value when condition was true",{context:"pine_docs_returns"})],remarks:[$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"})],examples:["slow = sma(close, 7)","fast = sma(close, 14)","// get value of close on second cross occurrence","valuewhen(cross(slow, fast), close, 1)"],seeAlso:["{@fun lowestbars}, {@fun highestbars}, {@fun barssince}, {@fun highest}, {@fun lowest}"],syntax:["valuewhen(condition, source, occurrence) → series[float]","valuewhen(condition, source, occurrence) → series[integer]"]},falling:{kind:"Built-in function",desc:[$.t("Test if the x series is now falling for y bars long.",{context:"pine_docs_desc"})],returns:[$.t("true if current x is less than any previous x for y bars back, false otherwise.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun rising}"],syntax:["falling(source, length) → series[bool]"]},rising:{kind:"Built-in function",desc:[$.t("Test if the x series is now rising for y bars long.",{context:"pine_docs_desc"})],returns:[$.t("true if current x is greater than any previous x for y bars back, false otherwise.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun falling}"],syntax:["rising(source, length) → series[bool]"]},roc:{kind:"Built-in function",desc:[$.t("Function roc (rate of change) showing the difference between current value of x and the value of x that was y days ago.",{context:"pine_docs_desc"}),$.t("It is calculated by the formula: 100 * change(src, length) / src[length].",{context:"pine_docs_desc"})],returns:[$.t("The rate of change of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],syntax:["roc(source, length) → series[float]"]},cci:{kind:"Built-in function",
desc:[$.t("The CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers",{context:"pine_docs_desc"})],returns:[$.t("Commodity channel index of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],syntax:["cci(source, length) → series[float]"]},variance:{kind:"Built-in function",desc:[$.t("Variance is the expectation of the squared deviation of a series from its mean ({@fun sma}), and it informally measures how far a set of numbers are spread out from their mean.",{context:"pine_docs_desc"})],returns:[$.t("Variance of x for y bars back.",{context:"pine_docs_returns"})],remarks:[$.t("This is a biased estimation of sample variance.",{context:"pine_docs_remarks"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun dev}, {@fun stdev}"],syntax:["variance(source, length) → series[float]"]},dev:{kind:"Built-in function",desc:[$.t("Measure of difference between the series and it's {@fun sma}",{context:"pine_docs_desc"})],returns:[$.t("Deviation of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["plot(dev(close, 10))","","// the same on pine","pine_dev(source, length) =>","    mean = sma(source, length)","    sum = 0.0","    for i = 0 to length - 1","        val = source[i]","        sum := sum + abs(val - mean)","    dev = sum/length","plot(pine_dev(close, 10))"],seeAlso:["{@fun variance}, {@fun stdev}"],syntax:["dev(source, length) → series[float]"]},stdev:{kind:"Built-in function",returns:[$.t("Standard deviation.",{context:"pine_docs_returns"})],remarks:[$.t("This is a biased estimation of standard deviation.",{context:"pine_docs_remarks"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],
examples:["plot(stdev(close, 5))","","//the same on pine","isZero(val, eps) => abs(val) <= eps","","SUM(fst, snd) =>","    EPS = 1e-10","    res = fst + snd","    if isZero(res, EPS)","        res := 0","    else","        if not isZero(res, 1e-4)","            res := res","        else","            15","","pine_stdev(src, length) =>","    avg = sma(src, length)","    sumOfSquareDeviations = 0.0","    for i = 0 to length - 1","        sum = SUM(src[i], -avg)","        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum","","    stdev = sqrt(sumOfSquareDeviations / length)","plot(pine_stdev(close, 5))"],seeAlso:["{@fun dev}, {@fun variance}"],syntax:["stdev(source, length) → series[float]"]},percentrank:{kind:"Built-in function",desc:[$.t("Percent rank is the percents of how many previous values was less than or equal to the current value of given series.",{context:"pine_docs_desc"})],returns:[$.t("Percent rank of x for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],syntax:["percentrank(source, length) → series[float]"]},offset:{kind:"Built-in function",desc:[$.t("Shifts series x on the y bars to the right.",{context:"pine_docs_desc"})],returns:[$.t("Shifted series.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"offset",type:"integer",info:$.t("Number of bars to offset, must be a positive number. Negative offsets are not supported.",{context:"pine_docs_args_info"})}],remarks:[$.t("If you need to shift the series to the left, use combination of {@fun offset} and {@fun plot} (with offset argument).",{context:"pine_docs_remarks"})],seeAlso:["offset argument of {@fun plot} function, square brackets [] operator"],syntax:["offset(source, offset) → series[bool]","offset(source, offset) → series[color]","offset(source, offset) → series[integer]","offset(source, offset) → series[float]"]},rma:{desc:[$.t("Moving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Exponential moving average of x with alpha = 1 / y.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"integer",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})}],examples:["plot(rma(close, 15))","","//the same on pine","pine_rma(src, length) =>","\talpha = 1/length","\tsum = 0.0","\tsum := na(sum[1]) ? sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])","plot(pine_rma(close, 15))"],seeAlso:["{@fun sma}, {@fun ema}, {@fun wma}, {@fun vwma}, {@fun swma}, {@fun alma}, {@fun rsi}"],syntax:["rma(source, length) → series[float]"]},rsi:{kind:"Built-in function",
desc:[$.t("Relative strength index. It is calculated based on rma's of upward and downward change of x.",{context:"pine_docs_desc"})],returns:[$.t("Relative strength index.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series"},{name:"y",type:"integer, series"}],remarks:[$.t("If x is a series and y is integer then x is a source series and y is a length.",{context:"pine_docs_remarks"}),$.t("If x is a series and y is a series then x and y are considered to be 2 calculated MAs for upward and downward changes.",{context:"pine_docs_remarks"})],examples:["plot(rsi(close, 7))","","// same on pine, but less efficient","pine_rsi(x, y) => ","    u = max(x - x[1], 0) // upward change","    d = max(x[1] - x, 0) // downward change","    rs = rma(u, y) / rma(d, y)","    res = 100 - 100 / (1 + rs)","    res","","plot(pine_rsi(close, 7))"],seeAlso:["{@fun rma}"],syntax:["rsi(x, y) → series[float]"]},dmi:{desc:[$.t("The dmi function returns the directional movement index.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Tuple of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX).",{context:"pine_docs_returns"})],args:[{name:"diLength",type:"integer",info:$.t("DI Period.",{context:"pine_docs_args_info"})},{name:"adxSmoothing",type:"integer",info:$.t("ADX Smoothing Period.",{context:"pine_docs_args_info"})}],examples:['study(title="Directional Movement Index", shorttitle="DMI", format=format.price, precision=4)','len = input(17, minval=1, title="DI Length")','lensig = input(14, title="ADX Smoothing", minval=1, maxval=50)',"[diplus, diminus, adx] = dmi(len, lensig)",'plot(adx, color=color.red, title="ADX")','plot(diplus, color=color.blue, title="+DI")','plot(diminus, color=color.orange, title="-DI")'],seeAlso:["{@fun rsi}, {@fun tsi}, {@fun mfi}"],syntax:["dmi(diLength, adxSmoothing) → [series[float], series[float], series[float]]"]},correlation:{kind:"Built-in function",desc:[$.t("Correlation coefficient. Describes the degree to which two series tend to deviate from their {@fun sma} values.",{context:"pine_docs_desc"})],returns:[$.t("Correlation coefficient.",{context:"pine_docs_returns"})],args:[{name:"source_a",info:$.t("Source series.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"source_b",info:$.t("Target series.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Length (number of bars back).",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun security}"],syntax:["correlation(source_a, source_b, length) → series[float]"]},tsi:{kind:"Built-in function",desc:[$.t("True strength index. It uses moving averages of the underlying momentum of a financial instrument.",{context:"pine_docs_desc"})],returns:[$.t("True strength index. A value in range [-1, 1]",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("Source series.",{context:"pine_docs_args_info"})},{name:"short_length",type:"integer",info:$.t("Short length.",{
context:"pine_docs_args_info"})},{name:"long_length",type:"integer",info:$.t("Long length.",{context:"pine_docs_args_info"})}],syntax:["tsi(source, short_length, long_length) → series[float]"]},linreg:{kind:"Built-in function",desc:[$.t("Linear regression curve. A line that best fits the prices specified over a user-defined time period. It is calculated using the least squares method. The result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where length is the y argument, offset is the z argument, intercept and slope are the values calculated with the least squares method on source series (x argument).",{context:"pine_docs_desc"})],returns:[$.t("Linear regression curve.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Source series.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",type:"series[integer]"},{name:"offset",type:"integer",info:$.t("Offset.",{context:"pine_docs_args_info"})}],syntax:["linreg(source, length, offset) → series[float]"]},stoch:{kind:"Built-in function",desc:[$.t("Stochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length))",{context:"pine_docs_desc"})],returns:[$.t("Stochastic.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Source series.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"high",info:$.t("Series of high.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"low",info:$.t("Series of low.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Length (number of bars back).",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun cog}"],syntax:["stoch(source, high, low, length) → series[float]"]},atr:{kind:"Built-in function",desc:[$.t("Function atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1]))",{context:"pine_docs_desc"})],returns:[$.t("Average true range.",{context:"pine_docs_returns"})],args:[{name:"length",type:"integer",info:$.t("Length (number of bars back).",{context:"pine_docs_args_info"})}],examples:["plot(atr(14))","","//the same on pine","pine_atr(length) =>","    trueRange = na(high[1])? high-low : max(max(high - low, abs(high - close[1])), abs(low - close[1]))","    //true range can be also calculated with tr(true)","    rma(trueRange, length)","","plot(pine_atr(14))"],seeAlso:["{@fun tr}, {@fun rma}"],syntax:["atr(length) → series[float]"]},fixnan:{kind:"Built-in function",desc:[$.t("For a given series replaces NaN values with previous nearest non-NaN value.",{context:"pine_docs_desc"})],returns:[$.t("Series without na gaps.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series"}],seeAlso:["{@fun na}, {@var na} (variable), {@fun nz}"],syntax:["fixnan(x) → series[float]","fixnan(x) → series[integer]","fixnan(x) → series[bool]","fixnan(x) → series[color]"]},cum:{kind:"Built-in function",
desc:[$.t("Cumulative (total) sum of x. In other words it's a sum of all elements of x.",{context:"pine_docs_desc"})],returns:[$.t("Total sum series.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series"}],seeAlso:["{@fun sum}"],syntax:["cum(x) → series[float]"]},change:{kind:"Built-in function",desc:[$.t("Difference between current value and previous, x - x[y].",{context:"pine_docs_desc"})],returns:[$.t("The result of subtraction.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series[float]"},{name:"length",info:$.t("Offset from the current bar to the previous bar. Optional, if not given, length = 1 is used. Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun mom}, {@fun cross}"],syntax:["change(source, length) → series[float]","change(source) → series[float]"]},mom:{kind:"Built-in function",desc:[$.t("Momentum of x price and x price y bars ago. This is simply a difference x - x[y].",{context:"pine_docs_desc"})],returns:[$.t("Momentum of x price and x price y bars ago.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Offset from the current bar to the previous bar. Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun change}"],syntax:["mom(source, length) → series[float]"]},vwap:{kind:"Built-in function",desc:[$.t("Volume weighted average price.",{context:"pine_docs_desc"})],returns:[$.t("Volume weighted average.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series",info:$.t("Source series.",{context:"pine_docs_args_info"})}],seeAlso:["{@var vwap} (variable)"],syntax:["vwap(x) → series[float]"]},swma:{desc:[$.t("Symmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6].",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Symmetrically weighted moving average",{context:"pine_docs_returns"})],args:[{name:"x",type:"series",info:$.t("Source series.",{context:"pine_docs_args_info"})}],examples:["plot(swma(close))","","// same on pine, but less efficient","pine_swma(x) =>","    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6","plot(pine_swma(close))"],seeAlso:["{@fun sma}, {@fun ema}, {@fun rma}, {@fun wma}, {@fun vwma}, {@fun alma}"],syntax:["swma(x) → series[float]"]},sar:{kind:"Built-in function",desc:[$.t("Parabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods.",{context:"pine_docs_desc"})],returns:[$.t("Parabolic SAR.",{context:"pine_docs_returns"})],args:[{name:"start",type:"float",info:$.t("Start.",{context:"pine_docs_args_info"})},{name:"inc",type:"float",info:$.t("Increment.",{context:"pine_docs_args_info"})},{name:"max",type:"float",info:$.t("Maximum.",{context:"pine_docs_args_info"})}],examples:["plot(sar(0.2, 0.2, .2), style=plot.style_cross, linewidth=3)"],
syntax:["sar(start, inc, max) → series[float]"]},avg:{kind:"Built-in function",desc:[$.t("Calculates average of all given series (elementwise).",{context:"pine_docs_desc"})],returns:[$.t("Average.",{context:"pine_docs_returns"})],seeAlso:["{@fun sum}, {@fun cum}, {@fun sma}"],syntax:["avg(x1, x2, ...) -> series[float]"]},security:{kind:"Built-in function",desc:[$.t("Request another symbol/resolution",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol.",{context:"pine_docs_args_info"})},{name:"resolution",type:"string",info:$.t("Resolution. An empty string is interpreted as the current resolution of the chart.",{context:"pine_docs_args_info"})},{name:"expression",info:$.t("An expression can be calculated and returned from the {@fun security} call. It can be a series or a tuple containing elements that can be cast to series.",{context:"pine_docs_args_info"}),type:"series[color]"},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.",{context:"pine_docs_args_info"})},{name:"lookahead",type:"const bool",info:$.t("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series.",{context:"pine_docs_returns"})],remarks:[$.t("PineScript code that uses this function could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("If you want to specify additional parameters for the requested symbol, e.g. session or adjustment type, you can use the tickerid() function.",{context:"pine_docs_remarks"}),$.t("It is not possible to pass a spread to this function using the 'ticker' variable. You can use the 'tickerid' variable or a string representation of the ticker, e.g. “AAPL+MSFT*TSLA”.",{context:"pine_docs_remarks"}),$.t("At the moment, up to 40 security calls can be present in a script.",{context:"pine_docs_remarks"}),$.t("Please note that using this variable/function can cause {html_markup_1}indicator repainting{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/pine-script-docs/en/v4/essential/Indicator_repainting.html">',html_markup_2:"</a>"
}),$.t("The resolution argument allowable values are:{ul}{li}1S, 5S, 15S, 30S - for seconds intervals (chart resolution should be less than or equal to the requested resolution){li_end}{li}from 1 to 1440 for minutes{li_end}{li}from 1D to 365D for days{li_end}{li}from 1W to 52W for weeks{li_end}{li}from 1M to 12M for months{li_end}{ul_end}",{context:"pine_docs_remarks"}).format({ul:"<ul>",ul_end:"</ul>",li:"<li>",li_end:"</li>"})],examples:['s = security("MSFT", "D", close) // 1 Day',"plot(s)","","expr = sma(close, 10)",'s1 = security("AAPL", "240", expr) // 240 Minutes',"plot(s1)","","// To avoid difference in calculation on history/realtime you can request not latest values and use merge strategy flags as follows:",'s2=security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_on)',"plot(s2)","f() => [open, high]",'[o, h] = security(syminfo.tickerid, "D", f())','[l, c] = security(syminfo.tickerid, "D", [low, close])',"plot((o + h + l + c) / 4)"],seeAlso:["{@var syminfo.ticker}, {@var syminfo.tickerid}, {@var timeframe.period}, {@fun correlation}, {@var barmerge.lookahead_off}, {@var barmerge.lookahead_on}"],syntax:["security(symbol, resolution, expression, gaps, lookahead) → series[float]","security(symbol, resolution, expression, gaps, lookahead) → series[integer]","security(symbol, resolution, expression, gaps, lookahead) → series[bool]","security(symbol, resolution, expression, gaps, lookahead) → series[color]","security(symbol, resolution, expression, gaps, lookahead) → <arg_expr_type>"]},financial:{kind:"Built-in function",desc:[$.t("Requests financial series for symbol.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL".',{context:"pine_docs_args_info"})},{name:"financial_id",type:"string",info:$.t("Financial identifier. You can find the list of available ids via our {html_markup_1}Help Center{html_markup_2}.",{context:"pine_docs_args_info"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/?solution=43000564727">',html_markup_2:"</a>"})},{name:"period",type:"string",info:$.t('Reporting period. Possible values are "TTM", "FY", "FQ".',{context:"pine_docs_args_info"})},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is {@var barmerge.gaps_off}",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series.",{context:"pine_docs_returns"})],examples:['f = financial("NASDAQ:MSFT", "ACCOUNTS_PAYABLE", "FY")',"plot(f)"],seeAlso:["{@var security}, {@var syminfo.tickerid}"],
syntax:["financial(symbol, financial_id, period, gaps) → series[float]"]},quandl:{kind:"Built-in function",desc:[$.t("Requests {html_markup_1}Quandl{html_markup_2} data for a symbol.",{context:"pine_docs_desc"}).format({html_markup_1:'<a target="blank" href="https://www.quandl.com" rel="nofollow">',html_markup_2:"</a>"})],args:[{name:"ticker",type:"string",info:$.t('Symbol. Note that the name of a time series and Quandl data feed should be divided by a forward slash. For example: "CFTC/SB_FO_ALL".',{context:"pine_docs_args_info"})},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is {@var barmerge.gaps_off}",{context:"pine_docs_args_info"})},{name:"index",type:"integer",info:$.t("A Quandl time-series column index.",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series.",{context:"pine_docs_returns"})],examples:['f = quandl("CFTC/SB_FO_ALL", barmerge.gaps_off, 0)',"plot(f)"],remarks:[$.t("You can learn more about how to find ticker and index values in our {html_markup_1}Help Center{html_markup_2}.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/chart/?solution=43000568613">',html_markup_2:"</a>"})],seeAlso:["{@var security}, {@var syminfo.tickerid}"],syntax:["quandl(ticker, gaps, index) → series[float]"]},tickerid:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting additional data for the script.",{context:"pine_docs_desc"})],args:[{name:"prefix",type:"string",info:$.t("Exchange prefix. For example: 'BATS', 'NYSE', 'NASDAQ'. Exchange prefix of main series is {@var syminfo.prefix}.",{context:"pine_docs_args_info"})},{name:"ticker",type:"string",info:$.t("Ticker name. For example 'AAPL', 'MSFT', 'EURUSD'. Ticker name of the main series is {@var syminfo.ticker}.",{context:"pine_docs_args_info"})},{name:"session",type:"string",info:$.t("Session type. Optional argument. Possible values: {@var session.regular}, {@var session.extended}. Session type of the current chart is {@var syminfo.session}. If session is not given, then {@var syminfo.session} value is used.",{context:"pine_docs_args_info"})},{name:"adjustment",type:"string",info:$.t("Adjustment type. Optional argument. Possible values: {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}. If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],
examples:['study("tickerid fun", overlay=true) ',"t = tickerid(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)","t2 = heikinashi(t)","c = security(t2, timeframe.period, low, true)","plot(c, style=plot.style_linebr)"],remarks:[$.t("You may use return value of {@fun tickerid} function as input argument for {@fun heikinashi}, {@fun renko}, {@fun linebreak}, {@fun kagi}, {@fun pointfigure} functions.",{context:"pine_docs_remarks"})],seeAlso:["{@var syminfo.tickerid} (variable), {@var syminfo.ticker}, {@var syminfo.session}, {@var session.extended}, {@var session.regular}, {@fun heikinashi}, {@var adjustment.none}, {@var adjustment.splits}, {@var adjustment.dividends}"],syntax:["tickerid(prefix, ticker, session, adjustment) → string"]},heikinashi:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting Heikin Ashi bar values.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol ticker identifier.",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],examples:["heikinashi_close = security(heikinashi(syminfo.tickerid), timeframe.period, close)","",'heikinashi_aapl_60_close = security(heikinashi("AAPL"), "60", close)'],seeAlso:["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun security}, {@fun renko}, {@fun linebreak}, {@fun kagi}, {@fun pointfigure}"],syntax:["heikinashi(symbol) → string"]},renko:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting Renko values.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol ticker identifier.",{context:"pine_docs_args_info"})},{name:"style",type:"string",info:$.t("Box Size Assignment Method: 'ATR', 'Traditional'.",{context:"pine_docs_args_info"})},{name:"param",type:"float",info:$.t("ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],examples:['renko_tickerid = renko(syminfo.tickerid, "ATR", 10)',"renko_close = security(renko_tickerid, timeframe.period, close)","plot(renko_close)"],seeAlso:["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun security}, {@fun heikinashi}, {@fun linebreak}, {@fun kagi}, {@fun pointfigure}"],syntax:["renko(symbol, style, param) → string"]},linebreak:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting Line Break values.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol ticker identifier.",{context:"pine_docs_args_info"})},{name:"number_of_lines",type:"integer",info:$.t("Number of line.",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],
examples:["linebreak_tickerid = linebreak(syminfo.tickerid, 3)","linebreak_close = security(linebreak_tickerid, timeframe.period, close)","plot(linebreak_close)"],seeAlso:["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun security}, {@fun heikinashi}, {@fun renko}, {@fun kagi}, {@fun pointfigure}"],syntax:["linebreak(symbol, number_of_lines) → string"]},kagi:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting Kagi values.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol ticker identifier.",{context:"pine_docs_args_info"})},{name:"reversal",type:"float",info:$.t("Reversal amount (absolute price value).",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],examples:["kagi_tickerid = kagi(syminfo.tickerid, 3)","kagi_close = security(kagi_tickerid, timeframe.period, close)","plot(kagi_close)"],seeAlso:["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun security}, {@fun heikinashi}, {@fun renko}, {@fun linebreak}, {@fun pointfigure}"],syntax:["kagi(symbol, reversal) → string"]},pointfigure:{kind:"Built-in function",desc:[$.t("Creates a ticker identifier for requesting Point & Figure values.",{context:"pine_docs_desc"})],args:[{name:"symbol",type:"string",info:$.t("Symbol ticker identifier.",{context:"pine_docs_args_info"})},{name:"source",type:"string",info:$.t("The source for calculating Point & Figure. Possible values are: 'hl', 'close'.",{context:"pine_docs_args_info"})},{name:"style",type:"string",info:$.t("Box Size Assignment Method: 'ATR', 'Traditional'.",{context:"pine_docs_args_info"})},{name:"param",type:"float",info:$.t("ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",{context:"pine_docs_args_info"})},{name:"reversal",type:"integer",info:$.t("Reversal amount.",{context:"pine_docs_args_info"})}],returns:[$.t("String value of ticker id, that can be supplied to {@fun security} function.",{context:"pine_docs_returns"})],examples:['pnf_tickerid = pointfigure(syminfo.tickerid, "hl", "Traditional", 1, 3)',"pnf_close = security(pnf_tickerid, timeframe.period, close)","plot(pnf_close)"],seeAlso:["{@var syminfo.tickerid}, {@var syminfo.ticker}, {@fun security}, {@fun heikinashi}, {@fun renko}, {@fun linebreak}, {@fun kagi}"],syntax:["pointfigure(symbol, source, style, param, reversal) → string"]},time:{kind:"Built-in function",desc:[$.t("The time function returns the UNIX time of the current bar for the specified resolution and session or NaN if the time point is out of session.",{context:"pine_docs_desc"})],returns:[$.t("UNIX time.",{context:"pine_docs_returns"})],args:[{name:"resolution",type:"string",info:$.t("Resolution. An empty string is interpreted as the current resolution of the chart.",{context:"pine_docs_args_info"})},{name:"session",type:"string",
info:$.t("Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",{context:"pine_docs_remarks"})],detailedDesc:[{desc:[],examples:["//@version=4",'study("Time", overlay=true)',"// Try this on chart AAPL,1","timeinrange(res, sess) => not na(time(res, sess)) ? 1 : 0",'plot(timeinrange("1", "1300-1400"), color=color.red)',"","// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:","newbar(res) => change(time(res)) == 0 ? 0 : 1",'plot(newbar("10"))']},{desc:[$.t("While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.",{context:"pine_docs_desc"}),$.t('If the days aren\'t specified, the session is considered to have been set from Monday to Friday (Saturday and Sunday are excluded as the weekend days), i.e. "1100-2000" is the same as "1100-1200:23456".',{context:"pine_docs_desc"}),$.t("",{context:"pine_docs_desc"}),$.t("For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:",{context:"pine_docs_desc"})],examples:["//@version=4",'study("Time", overlay=true)','t1 = time(timeframe.period, "0000-0000")',"bgcolor(t1 ? color.blue : na)"]},{desc:[$.t("You can change that by specifying the days:",{context:"pine_docs_desc"})],examples:["//@version=4",'study("Time - days", overlay=true)','t1 = time(timeframe.period, "0000-0000:1234567")',"bgcolor(t1 ? color.green : na)"]}],seeAlso:["{@var time} (variable)"],syntax:["time(resolution, session) → series[integer]","time(resolution) → series[integer]"]},time_close:{kind:"Built-in function",desc:[$.t("The time_close function returns the UNIX time of the close of the current bar for the specified resolution and session or NaN if the time point is out of session.",{context:"pine_docs_desc"})],returns:[$.t("UNIX time.",{context:"pine_docs_returns"})],args:[{name:"resolution",type:"string",info:$.t("Resolution. An empty string is interpreted as the current resolution of the chart.",{context:"pine_docs_args_info"})},{name:"session",type:"string",info:$.t("Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",{context:"pine_docs_remarks"})],detailedDesc:[{desc:[],examples:["//@version=4",'study("Time", overlay=true)','t1 = time_close(timeframe.period, "1200-1300")',"bgcolor(t1 ? color.blue : na)"]}],seeAlso:["{@var time_close} (variable)"],syntax:["time_close(resolution, session) → series[integer]","time_close(resolution) → series[integer]"]},timestamp:{kind:"Built-in function",
desc:[$.t("Function timestamp returns UNIX time of specified date and time.",{context:"pine_docs_desc"})],returns:[$.t("UNIX time.",{context:"pine_docs_returns"})],args:[{name:"timezone",type:"string",info:$.t("(Optional argument) Timezone",{context:"pine_docs_args_info"})},{name:"year",type:"integer",info:$.t("Year",{context:"pine_docs_args_info"})},{name:"month",type:"integer",info:$.t("Month",{context:"pine_docs_args_info"})},{name:"day",type:"integer",info:$.t("Day",{context:"pine_docs_args_info"})},{name:"hour",type:"integer",info:$.t("(Optional argument) Hour. Default is 0.",{context:"pine_docs_args_info"})},{name:"minute",type:"integer",info:$.t("(Optional argument) Minute. Default is 0.",{context:"pine_docs_args_info"})},{name:"second",type:"integer",info:$.t("(Optional argument) Second. Default is 0.",{context:"pine_docs_args_info"})},{name:"dateString",type:"string",info:$.t('A string containing the date and, optionally, the time and time zone. Its format must comply with either the {html_markup_1}IETF RFC 2822{html_markup_2} or {html_markup_3}ISO 8601{html_markup_4} standards ("DD MMM YYYY hh:mm:ss ±hhmm" or "YYYY-MM-DDThh:mm:ss±hh:mm", so "20 Feb 2020" or "2020-02-20"). If no time is supplied, "00:00" is used. If no time zone is supplied, GMT+0 will be used. Note that this diverges from the usual behavior of the function where it returns time in the exchange\'s timezone.',{context:"pine_docs_args_info"}).format({html_markup_1:'<a target="blank" href="https://tools.ietf.org/html/rfc2822#section-3.3" rel="nofollow">',html_markup_2:"</a>",html_markup_3:'<a target="blank" href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow">',html_markup_4:"</a>"})}],remarks:[$.t('UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default Timezone is {@var syminfo.timezone}, but it can be specified by GMT-notation (e.g "GMT-5", "GMT+5", "GMT+5:30", etc), or one of following values: ',{context:"pine_docs_remarks"}),'"America/New_York"','"America/Los_Angeles"','"America/Chicago"','"America/Phoenix"','"America/Toronto"','"America/Vancouver"','"America/Argentina/Buenos_Aires"','"America/El_Salvador"','"America/Sao_Paulo"','"America/Bogota"','"Europe/Moscow"','"Europe/Athens"','"Europe/Berlin"','"Europe/London"','"Europe/Madrid"','"Europe/Paris"','"Europe/Warsaw"','"Australia/Sydney"','"Australia/Brisbane"','"Australia/Adelaide"','"Australia/ACT"','"Asia/Almaty"','"Asia/Ashkhabad"','"Asia/Tokyo"','"Asia/Taipei"','"Asia/Singapore"','"Asia/Shanghai"','"Asia/Seoul"','"Asia/Tehran"','"Asia/Dubai"','"Asia/Kolkata"','"Asia/Hong_Kong"','"Asia/Bangkok"','"Pacific/Auckland"','"Pacific/Chatham"','"Pacific/Fakaofo"','"Pacific/Honolulu"'],
examples:["//@version=4",'study("My Script")',"plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)","plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)","plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",'plot(timestamp("GMT+6", 2016, 01, 19, 09, 30))',"plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",'plot(timestamp("GMT+3", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)','plot(timestamp("Feb 01 2020 22:10:05"))','plot(timestamp("2011-10-10T14:48:00"))','plot(timestamp("04 Dec 1995 00:12:00 GMT+5"))'],seeAlso:["{@fun time} (function) {@var time} (variable) {@var timenow} (variable) {@var syminfo.timezone} (variable)"],syntax:["timestamp(dateString) → const integer","timestamp(year, month, day, hour, minute, second) → integer","timestamp(timezone, year, month, day, hour, minute, second) → integer","timestamp(year, month, day, hour, minute, second) → series[integer]","timestamp(timezone, year, month, day, hour, minute, second) → series[integer]"]},year:{kind:"Built-in function",returns:[$.t("Year (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"}),$.t("Note that this function returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@var year} (variable), {@fun time}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],syntax:["year(time) → series[integer]","year(time, timezone) → series[integer]"]},month:{kind:"Built-in function",returns:[$.t("Month (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"}),$.t("Note that this function returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day.",{context:"pine_docs_remarks"})],
seeAlso:["{@var month} (variable), {@fun time}, {@fun year}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],syntax:["month(time) → series[integer]","month(time, timezone) → series[integer]"]},weekofyear:{kind:"Built-in function",returns:[$.t("Week of year (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"}),$.t("Note that this function returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@var weekofyear} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],syntax:["weekofyear(time) → series[integer]","weekofyear(time, timezone) → series[integer]"]},dayofmonth:{kind:"Built-in function",returns:[$.t("Day of month (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"}),$.t("Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day.",{context:"pine_docs_remarks"})],seeAlso:["{@var dayofmonth} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofweek}, {@fun hour}, {@fun minute}, {@fun second}"],syntax:["dayofmonth(time) → series[integer]","dayofmonth(time, timezone) → series[integer]"]},dayofweek:{kind:"Built-in function",returns:[$.t("Day of week (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",{context:"pine_docs_remarks"
}),$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"})],seeAlso:["{@var dayofweek} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun hour}, {@fun minute}, {@fun second}"],syntax:["dayofweek(time) → series[integer]","dayofweek(time, timezone) → series[integer]"]},hour:{kind:"Built-in function",returns:[$.t("Hour (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"})],seeAlso:["{@var hour} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun minute}, {@fun second}"],syntax:["hour(time) → series[integer]","hour(time, timezone) → series[integer]"]},minute:{kind:"Built-in function",returns:[$.t("Minute (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"})],seeAlso:["{@var minute} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun second}"],syntax:["minute(time) → series[integer]","minute(time, timezone) → series[integer]"]},second:{kind:"Built-in function",returns:[$.t("Second (in exchange timezone) for provided UNIX time.",{context:"pine_docs_returns"})],args:[{name:"time",type:"series",info:$.t("UNIX time in milliseconds.",{context:"pine_docs_args_info"})},{name:"timezone",type:"string",info:$.t("An optional parameter. Timezone.",{context:"pine_docs_args_info"})}],remarks:[$.t("UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970. By default, the Timezone is {@var syminfo.timezone}, possible values can be seen in {@fun timestamp}.",{context:"pine_docs_remarks"})],seeAlso:["{@var second} (variable), {@fun time}, {@fun year}, {@fun month}, {@fun dayofmonth}, {@fun dayofweek}, {@fun hour}, {@fun minute}"],syntax:["second(time) → series[integer]","second(time, timezone) → series[integer]"]},cross:{kind:"Built-in function",returns:[$.t("true if two series have crossed each other, otherwise false.",{context:"pine_docs_returns"})],args:[{
name:"x",type:"series"},{name:"y",type:"series"}],seeAlso:["{@fun change}"],syntax:["cross(x, y) → series[bool]"]},iff:{kind:"Built-in function",desc:[$.t("If ... then ... else ...",{context:"pine_docs_desc"})],returns:[$.t("y or z series.",{context:"pine_docs_returns"})],args:[{name:"condition",type:"series",info:$.t("Series with condition values. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true.",{context:"pine_docs_args_info"})},{name:"then",type:"series",info:$.t("Series with values to return if condition is true.",{context:"pine_docs_args_info"})},{name:"_else",type:"series",info:$.t("Series with values to return if condition is false. Use {@var na} for `_else` argument if you do not need 'else' branch.",{context:"pine_docs_args_info"})}],remarks:[$.t("{@fun iff} does exactly the same thing as ternary conditional operator {@op ?:} but in a functional style. Also {@fun iff} is slightly less efficient than operator {@op ?:}",{context:"pine_docs_remarks"})],examples:["// Draw circles at the bars where open crosses close","s1 = iff(cross(open, close), avg(open,close), na)","plot(s1, style=plot.style_circles, linewidth=4, color=color.green)"],seeAlso:["Ternary conditional operator {@op ?:}, {@var na}"],syntax:["iff(condition, then, _else) → bool","iff(condition, then, _else) → integer","iff(condition, then, _else) → float","iff(condition, then, _else) → color","iff(condition, then, _else) → series[float]","iff(condition, then, _else) → series[integer]","iff(condition, then, _else) → series[color]","iff(condition, then, _else) → string","iff(condition, then, _else) → input bool","iff(condition, then, _else) → input integer","iff(condition, then, _else) → input float","iff(condition, then, _else) → input string","iff(condition, then, _else) → input color","iff(condition, then, _else) → const bool","iff(condition, then, _else) → const integer","iff(condition, then, _else) → const float","iff(condition, then, _else) → const string","iff(condition, then, _else) → const color","iff(condition, then, _else) → series[bool]","iff(condition, then, _else) → series[string]","iff(condition, then, _else) → series[line]","iff(condition, then, _else) → series[label]","iff(condition, then, _else) → array[<array_type>]"]},cog:{kind:"Built-in function",desc:[$.t("The cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio.",{context:"pine_docs_desc"})],returns:[$.t("Center of Gravity.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["plot(cog(close, 10))","","// the same on pine","pine_cog(source, length) =>","    sum = sum(source, length)","    num = 0.0","    for i = 0 to length - 1","        price = source[i]","        num := num + price * (i + 1)","    -num / sum","","plot(pine_cog(close, 10))"],seeAlso:["{@fun stoch}"],
syntax:["cog(source, length) → series[float]"]},alma:{desc:[$.t("Arnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Arnaud Legoux Moving Average.",{context:"pine_docs_returns"})],args:[{name:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length). Can be series[integer].",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"offset",type:"float",info:$.t("Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0).",{context:"pine_docs_args_info"})},{name:"sigma",type:"float",info:$.t("Changes the smoothness of ALMA. The larger sigma the smoother ALMA.",{context:"pine_docs_args_info"})},{name:"floor",type:"bool",info:$.t("An optional parameter. Specifies whether the offset calculation is floored before ALMA is calculated. Default value is false.",{context:"pine_docs_args_info"})}],examples:["plot(alma(close, 9, 0.85, 6))","","// same on pine, but much less efficient","pine_alma(series, windowsize, offset, sigma) =>","    m = offset * (windowsize - 1)","    //m = floor(offset * (windowsize - 1)) // Used as m when floor=true","    s = windowsize / sigma","    norm = 0.0","    sum = 0.0","    for i = 0 to windowsize - 1","        weight = exp(-1 * pow(i - m, 2) / (2 * pow(s, 2)))","        norm := norm + weight","        sum := sum + series[windowsize - i - 1] * weight","    sum / norm","plot(pine_alma(close, 9, 0.85, 6))"],seeAlso:["{@fun sma}, {@fun ema}, {@fun rma}, {@fun wma}, {@fun vwma}, {@fun swma}"],syntax:["alma(series, length, offset, sigma) → series[float]","alma(series, length, offset, sigma, floor) → series[float]"]},cmo:{desc:[$.t("Chande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Chande Momentum Oscillator.",{context:"pine_docs_returns"})],args:[{name:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["study('My Script')","plot(cmo(close, 5), color=color.yellow)","","// the same on pine","f_cmo(src, length) =>","    float mom = change(src)","    float sm1 = sum((mom >= 0) ? mom : 0.0, length)","    float sm2 = sum((mom >= 0) ? 0.0 : -mom, length)","    return = 100 * (sm1 - sm2) / (sm1 + sm2)","","plot(f_cmo(close, 5))"],seeAlso:["{@fun rsi}, {@fun stoch}, {@fun sum}"],syntax:["cmo(series, length) → series[float]"]},mfi:{desc:[$.t("Money Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Money Flow Index.",{
context:"pine_docs_returns"})],args:[{name:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["//@version=4","study('My Script')","","plot(mfi(close, 5), color=color.yellow)","","// the same on pine","f_mfi(src, length) =>","    float upper = sum(volume * (change(src) <= 0.0 ? 0.0 : src), length)","    float lower = sum(volume * (change(src) >= 0.0 ? 0.0 : src), length)","    ","    if na(lower)","        float res = na","        return = res","    else","        return = rsi(upper, lower)","","plot(f_mfi(close, 5))"],seeAlso:["{@fun rsi}, {@fun sum}"],syntax:["mfi(series, length) → series[float]"]},wpr:{desc:[$.t("Williams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Williams %R.",{context:"pine_docs_returns"})],args:[{name:"length",info:$.t("Number of bars.",{context:"pine_docs_args_info"}),type:"series[integer]"}],examples:["//@version=4",'study("Williams %R", shorttitle="%R", format=format.price, precision=2)','plot(wpr(14), title="%R", color=#ff6d00, transp=0)'],seeAlso:["{@fun mfi}, {@fun cmo}"],syntax:["wpr(length) → series[float]"]},bb:{desc:[$.t("Bollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Bollinger Bands.",{context:"pine_docs_returns"})],args:[{name:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"mult",type:"float",info:$.t("Standard deviation factor",{context:"pine_docs_args_info"})}],examples:["//@version=4","study('My Script')","","[middle, upper, lower] = bb(close, 5, 4)","plot(middle, color=color.yellow)","plot(upper, color=color.yellow)","plot(lower, color=color.yellow)","","// the same on pine","f_bb(src, length, mult) =>","    float basis = sma(src, length)","    float dev = mult * stdev(src, length)","    [basis, basis + dev, basis - dev]","","[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)","","plot(pineMiddle)","plot(pineUpper)","plot(pineLower)"],seeAlso:["{@fun sma}, {@fun stdev}, {@fun kc}"],syntax:["bb(series, length, mult) → [series[float], series[float], series[float]]"]},bbw:{desc:[$.t("Bollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Bollinger Bands Width.",{context:"pine_docs_returns"})],args:[{name:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"
}),type:"series[float]"},{name:"length",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"mult",type:"float",info:$.t("Standard deviation factor",{context:"pine_docs_args_info"})}],examples:["//@version=4","study('My Script')","","plot(bbw(close, 5, 4), color=color.yellow)","","// the same on pine","f_bbw(src, length, mult) =>","    float basis = sma(src, length)","    float dev = mult * stdev(src, length)","    ((basis + dev) - (basis - dev)) / basis","","plot(f_bbw(close, 5, 4))"],seeAlso:["{@fun bb}, {@fun sma}, {@fun stdev}"],syntax:["bbw(series, length, mult) → series[float]"]},kc:{desc:[$.t("Keltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Keltner Channels.",{context:"pine_docs_returns"})],args:[{name:"series",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"integer",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})},{name:"mult",type:"float",info:$.t("Standard deviation factor",{context:"pine_docs_args_info"})},{name:"useTrueRange",type:"bool",info:$.t("An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low)",{context:"pine_docs_args_info"})}],examples:["//@version=4","study('My Script')","","[middle, upper, lower] = kc(close, 5, 4)","plot(middle, color=color.yellow)","plot(upper, color=color.yellow)","plot(lower, color=color.yellow)","","","// the same on pine","f_kc(src, length, mult, useTrueRange) =>","    float basis = ema(src, length)","    float range = (useTrueRange) ? tr : (high - low)","    float rangeEma = ema(range, length)","    [basis, basis + rangeEma * mult, basis - rangeEma * mult]","    ","[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)","","plot(pineMiddle)","plot(pineUpper)","plot(pineLower)"],seeAlso:["{@fun ema}, {@fun atr}, {@fun bb}"],syntax:["kc(series, length, mult) → [series[float], series[float], series[float]]","kc(series, length, mult, useTrueRange) → [series[float], series[float], series[float]]"]},kcw:{desc:[$.t("Keltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel.",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("Keltner Channels Width.",{context:"pine_docs_returns"})],args:[{name:"series",type:"series",info:$.t("Series of values to process.",{context:"pine_docs_args_info"})},{name:"length",type:"integer",info:$.t("Number of bars (length).",{context:"pine_docs_args_info"})},{name:"mult",type:"float",info:$.t("Standard deviation factor",{context:"pine_docs_args_info"})},{name:"useTrueRange",type:"bool",
info:$.t("An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low)",{context:"pine_docs_args_info"})}],examples:["//@version=4","study('My Script')","","plot(kcw(close, 5, 4), color=color.yellow)","","// the same on pine","f_kcw(src, length, mult, useTrueRange) =>","    float basis = ema(src, length)","    float range = (useTrueRange) ? tr : (high - low)","    float rangeEma = ema(range, length)","    ","    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis","","plot(f_kcw(close, 5, 4, true))"],seeAlso:["{@fun kc}, {@fun ema}, {@fun atr}, {@fun bb}"],syntax:["kcw(series, length, mult) → series[float]","kcw(series, length, mult, useTrueRange) → series[float]"]},float:{desc:[$.t("Casts na to float",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to float.",{context:"pine_docs_returns"})],seeAlso:["{@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],syntax:["float(x) → const float","float(x) → input float","float(x) → float","float(x) → series[float]"]},int:{desc:[$.t("Casts na or truncates float value to int",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to int.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],syntax:["int(x) → integer","int(x) → input integer","int(x) → const integer","int(x) → series[integer]"]},bool:{desc:[$.t("Casts na to bool",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to bool.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],syntax:["bool(x) → const bool","bool(x) → input bool","bool(x) → bool","bool(x) → series[bool]"]},color:{desc:[$.t("Casts na to color",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to color.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun bool}, {@fun string}, {@fun line}, {@fun label}"],syntax:["color(x) → const color","color(x) → input color","color(x) → color","color(x) → series[color]"]},string:{desc:[$.t("Casts na to string",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to string.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun line}, {@fun label}"],syntax:["string(x) → const string","string(x) → input string","string(x) → string","string(x) → series[string]"]},line:{desc:[$.t("Casts na to line",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to line.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun label}"],syntax:["line(x) → series[line]"]},label:{
desc:[$.t("Casts na to label",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to label.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}"],syntax:["label(x) → series[label]"]},table:{desc:[$.t("Casts na to table",{context:"pine_docs_desc"})],kind:"Built-in function",returns:[$.t("The value of the argument after casting to table.",{context:"pine_docs_returns"})],seeAlso:["{@fun float}, {@fun int}, {@fun bool}, {@fun color}, {@fun string}, {@fun line}, {@fun label}"],syntax:["table(x) → series[table]"]},tostring:{kind:"Built-in function",returns:[$.t("String representation of x argument.",{context:"pine_docs_returns"})],args:[{name:"x",type:"float, array ID",info:$.t("Number, or ID of an array of type string, float or int to be converted to a string.",{context:"pine_docs_args_info"})},{name:"y",type:"string",info:$.t("Format string. Optional argument. The default value is '#.##########'. Accepts these format.* constants: {@var format.mintick}, {@var format.percent}, {@var format.volume}.",{context:"pine_docs_args_info"})}],remarks:[$.t("To display trailing zeros use 0 instead of a '#' symbol. For example, '#.000'.",{context:"pine_docs_remarks"}),$.t("Using formatting for the float values will round output values, e.g. tostring(3.99, '#') will return value of 4.",{context:"pine_docs_remarks"}),$.t("When using {@var format.mintick}, the value will be rounded to the nearest number that can be divided by {@var syminfo.mintick}, without the remainder. The string is returned with trailing zeroes.",{context:"pine_docs_remarks"})],syntax:["tostring(x) → series[string]","tostring(x, y) → series[string]","tostring(x) → string","tostring(x, y) → string"]},tonumber:{kind:"Built-in function",returns:[$.t("A float version of the string if it contains a valid number, na otherwise.",{context:"pine_docs_returns"})],args:[{name:"x",type:"series[string]",info:$.t("String representation of an int or float.",{context:"pine_docs_args_info"})}],syntax:["tonumber(x) → series[float]"]},"str.replace_all":{kind:"Built-in function",desc:[$.t("Replaces each occurrence of the target string in the source string with the replacement string.",{context:"pine_docs_desc"})],returns:[$.t("Processed string.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Source string.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"target",info:$.t("String to be replaced.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"replacement",info:$.t("String to be substituted for each occurrence of target string.",{context:"pine_docs_args_info"}),type:"series[string]"}],syntax:["str.replace_all(source, target, replacement) → string","str.replace_all(source, target, replacement) → series[string]"]},"str.split":{kind:"Built-in function",desc:[$.t("Divides a string into an array of substrings and returns its array id.",{context:"pine_docs_desc"})],syntax:["str.split(string, separator) → string[]"],
returns:[$.t("The id of an array of strings.",{context:"pine_docs_returns"})],args:[{name:"string",info:$.t("Source string.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"separator",info:$.t("The string separating each substring.",{context:"pine_docs_args_info"}),type:"series[string]"}]},"str.length":{kind:"Built-in function",desc:[$.t("Returns an integer corresponding to the amount of chars in that string.",{context:"pine_docs_desc"})],returns:[$.t("The number of chars in source string.",{context:"pine_docs_returns"})],args:[{name:"string",info:$.t("Source string.",{context:"pine_docs_args_info"}),type:"series[string]"}],syntax:["str.length(string) → const integer","str.length(string) → integer","str.length(string) → series[integer]"]},percentile_nearest_rank:{kind:"Built-in function",desc:[$.t("Calculates percentile using method of Nearest Rank.",{context:"pine_docs_desc"})],returns:[$.t("z-th percentile of x series for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process (source).",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars back (length).",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"percentage",type:"float",info:$.t("Percentage, a number from range 0..100.",{context:"pine_docs_args_info"})}],remarks:[$.t("Using the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile.",{context:"pine_docs_remarks"}),$.t("A percentile calculated using the Nearest Rank method will always be a member of the input data set.",{context:"pine_docs_remarks"}),$.t("The 100th percentile is defined to be the largest value in the input data set.",{context:"pine_docs_remarks"})],seeAlso:["{@fun percentile_linear_interpolation}","http://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method"],syntax:["percentile_nearest_rank(source, length, percentage) → series[float]"]},percentile_linear_interpolation:{kind:"Built-in function",desc:[$.t("Calculates percentile using method of linear interpolation between the two nearest ranks.",{context:"pine_docs_desc"})],returns:[$.t("z-th percentile of x series for y bars back.",{context:"pine_docs_returns"})],args:[{name:"source",info:$.t("Series of values to process (source).",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"length",info:$.t("Number of bars back (length).",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"percentage",type:"float",info:$.t("Percentage, a number from range 0..100.",{context:"pine_docs_args_info"})}],remarks:[$.t("Note that a percentile calculated using this method will NOT always be a member of the input data set.",{context:"pine_docs_remarks"})],seeAlso:["{@fun percentile_nearest_rank}"],syntax:["percentile_linear_interpolation(source, length, percentage) → series[float]"]},crossover:{kind:"Built-in function",returns:[$.t("true if `x` crossed over `y` otherwise false",{context:"pine_docs_returns"})],
desc:[$.t("The `x`-series is defined as having crossed over `y`-series if the value of `x` is greater than the value of `y` and the value of `x` was less than the value of `y` on the bar immediately preceding the current bar.",{context:"pine_docs_desc"})],args:[{name:"x",type:"float",info:$.t("Data series `x`.",{context:"pine_docs_args_info"})},{name:"y",type:"float",info:$.t("Data series `y`.",{context:"pine_docs_args_info"})}],syntax:["crossover(x, y) → series[bool]"]},crossunder:{kind:"Built-in function",returns:[$.t("true if `x` crossed under `y` otherwise false",{context:"pine_docs_returns"})],desc:[$.t("The `x`-series is defined as having crossed under `y`-series if the value of `x` is less than the value of `y` and the value of `x` was greater than the value of `y` on the bar immediately preceding the current bar.",{context:"pine_docs_desc"})],args:[{name:"x",type:"float",info:$.t("Data series `x`.",{context:"pine_docs_args_info"})},{name:"y",type:"float",info:$.t("Data series `y`.",{context:"pine_docs_args_info"})}],syntax:["crossunder(x, y) → series[bool]"]},strategy:{kind:"Built-in annotation function",desc:[$.t("The function sets a number of strategy properties.",{context:"pine_docs_desc"})],args:[{name:"title",type:"const string",info:$.t("study title that would be seen in Indicators/Strategies widget. Argument IS REQUIRED.",{context:"pine_docs_args_info"})},{name:"shorttitle",type:"const string",info:$.t("study short title that would be seen in the chart legend. Argument is optional.",{context:"pine_docs_args_info"})},{name:"overlay",type:"const bool",info:$.t("if true the study will be added as an overlay for the main series. If false - it would be added on a separate chart pane. Default is false.",{context:"pine_docs_args_info"})},{name:"format",type:"const string",info:$.t("type of formatting study values on the price axis. Possible values are: {@var format.inherit}, {@var format.price}, {@var format.volume}. Default is {@var format.inherit}.",{context:"pine_docs_args_info"})},{name:"precision",type:"const integer",info:$.t("number of digits after the floating point for study values on the price axis. Must be a non negative integer and not greater than 16. If omitted, using formatting from parent series. If format is {@var format.inherit} and this argument is set, then format becomes {@var format.price}.",{context:"pine_docs_args_info"})},{name:"scale",type:"const integer",info:$.t("price scale that the indicator should be attached to. Possible values are: {@var scale.right}, {@var scale.left}, {@var scale.none}. Value {@var scale.none} can be applied only in combination with 'overlay=true' setting. If omitted, using scale from main series.",{context:"pine_docs_args_info"})},{name:"pyramiding",type:"const integer",info:$.t("The maximum number of entries allowed in the same direction. If the value is 0, only one entry order in the same direction can be opened, and additional entry orders are rejected. The default value is 0.",{context:"pine_docs_args_info"})},{name:"calc_on_order_fills",
type:"const bool",info:$.t("Additional one time intrabar order calculation. If the parameter is set to 'true', then the strategy is recalculated once intrabar after an order is filled (not only at close of the bar). The default value is 'false'.",{context:"pine_docs_args_info"})},{name:"calc_on_every_tick",type:"const bool",info:$.t("Additional intrabar strategy calculations. If the parameter is 'true', then the strategy will calculate on every tick in real-time, rather than on bars' closes. The parameter does not affect strategy calculation on historical data. The default value is 'false'.",{context:"pine_docs_args_info"})},{name:"max_bars_back",type:"const integer",info:$.t("Maximum number of bars available for a strategy for historical reference. This parameter is applied to every built-in or user variable in the script if there is a reference to historical data of a variable in the script code (‘[]’ operator is used). Variable buffer sizes in the Pine Script are typically autodetected. This however is not possible in certain cases which is why the parameter allows a user to manually set the lower bound of this value. NOTE: using of the {@fun max_bars_back} function instead of the parameter is optimal because it applies to only one variable.",{context:"pine_docs_args_info"})},{name:"backtest_fill_limits_assumption",type:"const integer",info:$.t("Limit order execution assumption. Limit orders are filled intrabar only if market price exceeds the limit order level by the specified number of ticks.",{context:"pine_docs_args_info"})},{name:"default_qty_type",type:"const string",info:$.t("Parameter to determine the number of contracts/shares/lots/units to trade, if the 'qty' = 'NaN'. The allowed values are: {@var strategy.fixed} (fixed quantity by default), {@var strategy.cash} (specified in currency of the symbol and the amount is converted into quantity), {@var strategy.percent_of_equity} (% of currently available equity).",{context:"pine_docs_args_info"})},{name:"default_qty_value",type:"const float",info:$.t("Number of contracts/shares/lots/units if 'default_qty_type'={@var strategy.fixed} is used; or amount of cash in currency of the symbol if 'default_qty_type'={@var strategy.cash} is used; or number of percents of currently available equity if 'default_qty_type'={@var strategy.percent_of_equity} is used.",{context:"pine_docs_args_info"})},{name:"currency",type:"const string",info:$.t("Account currency for this strategy. Possible values are: {@var NONE}, {@var USD}, {@var EUR}, {@var AUD}, {@var GBP}, {@var NZD}, {@var CAD}, {@var CHF}, {@var HKD}, {@var JPY}, {@var NOK}, {@var SEK}, {@var SGD}, {@var TRY}, {@var ZAR}",{context:"pine_docs_args_info"})},{name:"linktoseries",type:"const bool",info:$.t("if true then the study will be always on the same pane and same price scale as the main series. Should be used only in combination with 'overlay=true'. Default is false.",{context:"pine_docs_args_info"})},{name:"slippage",type:"const integer",
info:$.t("Slippage in ticks to be added to/subtracted from the fill price of buy/sell market or stop orders. If mintick=0.01 and slippage=5, the amount of slippage will be 5*0.01=0.05.",{context:"pine_docs_args_info"})},{name:"commission_type",type:"const string",info:$.t("Commission type for an order. The allowed values are: {@var strategy.commission.percent} (a percentage of the cash volume of order), {@var strategy.commission.cash_per_contract} (money displayed in the account currency per contract), {@var strategy.commission.cash_per_order} (money displayed in the account currency per order).",{context:"pine_docs_args_info"})},{name:"commission_value",type:"const float",info:$.t("Commission value for an order. Depending on the type selected  (commission_type) includes percentage or money.",{context:"pine_docs_args_info"})},{name:"process_orders_on_close",type:"const bool",info:$.t("When set to `true`, generates an additional attempt to execute orders after a bar closes and strategy calculations are completed. If the orders are market orders, the broker emulator executes them before the next bar's open. If the orders are conditional on price, they will only be filled if the price conditions are met. This option is useful if you wish to close positions on the current bar. The default value is 'false'.",{context:"pine_docs_args_info"})},{name:"close_entries_rule",type:"const string",info:$.t("Determines the order in which orders are closed. Allowed values are: 'FIFO' or 'ANY'. FIFO (First-In, First-Out) means that when several trades are open, the earliest trades must be closed first. This rule applies to stocks, futures and US forex (NFA Compliance Rule 2-43b). 'ANY' means that trades may be closed in any order; this is allowed in non-US forex. The default value is 'FIFO'.",{context:"pine_docs_args_info"})},{name:"max_lines_count",type:"const integer",info:$.t("The number of last line drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})},{name:"max_labels_count",type:"const integer",info:$.t("The number of last label drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})},{name:"margin_long",type:"const integer",info:$.t("Margin long is the percentage of the purchase price of a security that must be covered by cash or collateral for long positions. The default value is 100 and must be a non negative integer.",{context:"pine_docs_args_info"})},{name:"margin_short",type:"const integer",info:$.t("Margin short is the percentage of the purchase price of a security that must be covered by cash or collateral for short positions. The default value is 100 and must be a non negative integer.",{context:"pine_docs_args_info"})},{name:"max_boxes_count",type:"const integer",info:$.t("The number of last box drawings displayed. The default value is 50 and the maximum allowed is 500.",{context:"pine_docs_args_info"})}],remarks:[$.t("Every strategy script must have one {@fun strategy} call.",{context:"pine_docs_remarks"
}),$.t("PineScript code that uses argument calc_on_every_tick=true could calculate differently on history and real-time data.",{context:"pine_docs_remarks"}),$.t("When using non-standard types of chart as a basis for strategy, you need to realize that the result will be different. The orders will be executed at the prices of this chart (e.g.for Heikin Ashi it’ll take Heikin Ashi prices (the average ones) not the real market prices). Therefore we highly recommend you to use standard chart type for strategies.",{context:"pine_docs_remarks"})],examples:["strategy(title='MyStrategy')",'strategy(title="MyStrategy", shorttitle="MS", pyramiding = 10)'],syntax:["strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, max_lines_count, max_labels_count, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, max_boxes_count) → void"]},"strategy.entry":{kind:"Built-in function",desc:[$.t("It is a command to enter market position. If an order with the same ID is already pending, it is possible to modify the order. If there is no order with the specified ID, a new order is placed. To deactivate an entry order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. In comparison to the function {@fun strategy.order}, the function {@fun strategy.entry} is affected by pyramiding and it can reverse market position correctly. If both 'limit' and 'stop' parameters are 'NaN', the order type is market order.",{context:"pine_docs_desc"})],args:[{name:"id",info:$.t("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"long",type:"bool",info:$.t("A required parameter. Market position direction: 'true' or 'strategy.long' is for long, 'false' or 'strategy.short' is for short.",{context:"pine_docs_args_info"})},{name:"qty",type:"float",info:$.t("An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"limit",type:"float",info:$.t("An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.",{context:"pine_docs_args_info"})},{name:"stop",type:"float",info:$.t("An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.",{context:"pine_docs_args_info"})},{name:"oca_name",type:"string",info:$.t("An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.",{context:"pine_docs_args_info"})},{name:"oca_type",type:"string",
info:$.t("An optional parameter. Type of the OCA group. The allowed values are: {@var strategy.oca.none} - the order should not belong to any particular OCA group; {@var strategy.oca.cancel} - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; {@var strategy.oca.reduce} - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.",{context:"pine_docs_args_info"})},{name:"comment",type:"string",info:$.t("An optional parameter. Additional notes on the order.",{context:"pine_docs_args_info"})},{name:"when",type:"bool",info:$.t("An optional parameter. Condition of the order. The order is placed if condition is 'true'. If condition is 'false', nothing happens (the previously placed order with the same ID is not cancelled). Default value is 'true'.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy(title = "simple gap strategy example")','strategy.entry("enter long", true, 1, when = open > high[1]) // enter long by market if current open great then previous high','strategy.entry("enter short", false, 1, when = open < low[1]) // enter short by market if current open less then previous low'],syntax:["strategy.entry(id, long, qty, limit, stop, oca_name, oca_type, comment, when, alert_message) → void"]},"strategy.order":{kind:"Built-in function",desc:[$.t("It is a command to place order. If an order with the same ID is already pending, it is possible to modify the order. If there is no order with the specified ID, a new order is placed. To deactivate order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. In comparison to the function {@fun strategy.entry}, the function {@fun strategy.order} is not affected by pyramiding. If both 'limit' and 'stop' parameters are 'NaN', the order type is market order.",{context:"pine_docs_desc"})],args:[{name:"id",info:$.t("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"long",type:"bool",info:$.t("A required parameter. Order direction: 'true' or 'strategy.long' is for buy, 'false' or 'strategy.short' is for sell.",{context:"pine_docs_args_info"})},{name:"qty",type:"float",info:$.t("An optional parameter. Number of contracts/shares/lots/units to trade. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"limit",type:"float",info:$.t("An optional parameter. Limit price of the order. If it is specified, the order type is either 'limit', or 'stop-limit'. 'NaN' should be specified for any other order type.",{context:"pine_docs_args_info"})},{name:"stop",type:"float",
info:$.t("An optional parameter. Stop price of the order. If it is specified, the order type is either 'stop', or 'stop-limit'. 'NaN' should be specified for any other order type.",{context:"pine_docs_args_info"})},{name:"oca_name",type:"string",info:$.t("An optional parameter. Name of the OCA group the order belongs to. If the order should not belong to any particular OCA group, there should be an empty string.",{context:"pine_docs_args_info"})},{name:"oca_type",type:"string",info:$.t("An optional parameter. Type of the OCA group. The allowed values are: {@var strategy.oca.none} - the order should not belong to any particular OCA group; {@var strategy.oca.cancel} - the order should belong to an OCA group, where as soon as an order is filled, all other orders of the same group are cancelled; {@var strategy.oca.reduce} - the order should belong to an OCA group, where if X number of contracts of an order is filled, number of contracts for each other order of the same OCA group is decreased by X.",{context:"pine_docs_args_info"})},{name:"comment",type:"string",info:$.t("An optional parameter. Additional notes on the order.",{context:"pine_docs_args_info"})},{name:"when",type:"bool",info:$.t("An optional parameter. Condition of the order. The order is placed if condition is 'true'. If condition is 'false', nothing happens (the previously placed order with the same ID is not cancelled). Default value is 'true'.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy(title = "simple gap strategy example")','strategy.order("buy", true, 1, when = open > high[1]) // buy by market if current open great then previous high','strategy.order("sell", false, 1, when = open < low[1]) // sell by market if current open less then previous low'],syntax:["strategy.order(id, long, qty, limit, stop, oca_name, oca_type, comment, when, alert_message) → void"]},"strategy.exit":{kind:"Built-in function",
desc:[$.t("It is a command to exit either a specific entry, or whole market position. If an order with the same ID is already pending, it is possible to modify the order. If an entry order was not filled, but an exit order is generated, the exit order will wait till entry order is filled and then the exit order is placed. To deactivate an exit order, the command {@fun strategy.cancel} or {@fun strategy.cancel_all} should be used. If the function {@fun strategy.exit} is called once, it exits a position only once. If you want to exit multiple times, the command {@fun strategy.exit} should be called multiple times. If you use a stop loss and a trailing stop, their order type is 'stop', so only one of them is placed (the one that is supposed to be filled first). If all the following parameters 'profit', 'limit', 'loss', 'stop', 'trail_points', 'trail_offset' are 'NaN', the command will fail. To use market order to exit, the command {@fun strategy.close} or {@fun strategy.close_all} should be used.",{context:"pine_docs_desc"})],args:[{name:"id",info:$.t("A required parameter. The order identifier. It is possible to cancel or modify an order by referencing its identifier.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"from_entry",info:$.t("An optional parameter. The identifier of a specific entry order to exit from it. To exit all entries an empty string should be used. The default values is empty string.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"qty",type:"float",info:$.t("An optional parameter. Number of contracts/shares/lots/units to exit a trade with. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"qty_percent",type:"float",info:$.t("An optional parameter. Defines the percentage of entered contracts/shares/lots/units to exit a trade with. When its value is not NaN, its priority is higher than that of the 'qty' parameter. Its value can range from 0 to 100. If 'qty' is NaN, the default value of 'qty_percent' is 100.",{context:"pine_docs_args_info"})},{name:"profit",type:"float",info:$.t("An optional parameter. Profit target (specified in ticks). If it is specified, a limit order is placed to exit market position when the specified amount of profit (in ticks) is reached. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"limit",type:"float",info:$.t("An optional parameter. Profit target (requires a specific price). If it is specified, a limit order is placed to exit market position at the specified price (or better). Priority of the parameter 'limit' is higher than priority of the parameter 'profit' ('limit' is used instead of 'profit', if its value is not 'NaN'). The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"loss",type:"float",info:$.t("An optional parameter. Stop loss (specified in ticks). If it is specified, a stop order is placed to exit market position when the specified amount of loss (in ticks) is reached. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"stop",type:"float",
info:$.t("An optional parameter. Stop loss (requires a specific price). If it is specified, a stop order is placed to exit market position at the specified price (or worse). Priority of the parameter 'stop' is higher than priority of the parameter 'loss' ('stop' is used instead of 'loss', if its value is not 'NaN'). The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"trail_price",type:"float",info:$.t("An optional parameter. Trailing stop activation level (requires a specific price). If it is specified, a trailing stop order will be placed when the specified price level is reached. The offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"trail_points",type:"float",info:$.t("An optional parameter. Trailing stop activation level (profit specified in ticks). If it is specified, a trailing stop order will be placed when the calculated price level (specified amount of profit) is reached. The offset (in ticks) to determine initial price of the trailing stop order is specified in the 'trail_offset' parameter: X ticks lower than activation level to exit long position; X ticks higher than activation level to exit short position. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"trail_offset",type:"float",info:$.t("An optional parameter. Trailing stop price (specified in ticks). The offset in ticks to determine initial price of the trailing stop order: X ticks lower than 'trail_price' or 'trail_points' to exit long position; X ticks higher than 'trail_price' or 'trail_points' to exit short position. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"oca_name",type:"string",info:$.t("An optional parameter. Name of the OCA group (oca_type = {@var strategy.oca.reduce}) the profit target, the stop loss / the trailing stop orders belong to. If the name is not specified, it will be generated automatically.",{context:"pine_docs_args_info"})},{name:"comment",type:"string",info:$.t("An optional parameter. Additional notes on the order.",{context:"pine_docs_args_info"})},{name:"when",type:"bool",info:$.t("An optional parameter. Condition of the order. The order is placed if condition is 'true'. If condition is 'false', nothing happens (the previously placed order with the same ID is not cancelled). Default value is 'true'.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],
examples:['strategy(title = "simple strategy exit example")','strategy.entry("long", true, 1, when = open > high[1]) // enter long by market if current open great then previous high','strategy.exit("exit", "long", profit = 10, loss = 5) // generate full exit bracket (profit 10 points, loss 5 points per contract) from entry with name "long"'],syntax:["strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, when, alert_message) → void"]},"strategy.cancel":{kind:"Built-in function",desc:[$.t("It is a command to cancel/deactivate pending orders by referencing their names, which were generated by the functions: {@fun strategy.order}, {@fun strategy.entry} and {@fun strategy.exit}.",{context:"pine_docs_desc"})],args:[{name:"id",info:$.t("A required parameter. The order identifier. It is possible to cancel an order by referencing its identifier.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"when",type:"bool",info:$.t("An optional parameter. Condition to cancel an order with specified ID. If condition is true, then the order with specified ID will be cancelled. Default value is 'true'.",{context:"pine_docs_args_info"})}],examples:['strategy(title = "simple order cancellation example")',"conditionForBuy = open > high[1]",'strategy.entry("long", true, 1, limit = low, when = conditionForBuy) // enter long using limit order at low price of current bar if conditionForBuy is true','strategy.cancel("long", when = not conditionForBuy) // cancel the entry order with name "long" if conditionForBuy is false'],syntax:["strategy.cancel(id, when) → void"]},"strategy.cancel_all":{kind:"Built-in function",desc:[$.t("It is a command to cancel/deactivate all pending orders, which were generated by the functions: {@fun strategy.order}, {@fun strategy.entry} and {@fun strategy.exit}.",{context:"pine_docs_desc"})],args:[{name:"when",type:"bool",info:$.t(" An optional parameter. Condition to cancel all orders. If condition is true, then all active orders will be cancelled. Default value is 'true'.",{context:"pine_docs_args_info"})}],examples:['strategy(title = "simple all orders cancellation example")',"conditionForBuy1 = open > high[1]",'strategy.entry("long entry 1", true, 1, limit = low, when = conditionForBuy1) // enter long by limit if conditionForBuy1 is true',"conditionForBuy2 = conditionForBuy1 and open[1] > high[2]",'strategy.entry("long entry 2", true, 1, limit = lowest(low, 2), when = conditionForBuy2) // enter long by limit if conditionForBuy2 is true',"conditionForStopTrading = open < lowest(low, 2)","strategy.cancel_all(conditionForStopTrading) // cancel both limit orders if the conditon conditionForStopTrading is true"],syntax:["strategy.cancel_all(when) → void"]},pivothigh:{kind:"Built-in function",desc:[$.t("This function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point.",{context:"pine_docs_desc"})],returns:[$.t("Price of the point or 'NaN'.",{context:"pine_docs_returns"})],args:[{
name:"source",type:"series",info:$.t("An optional parameter. Data series to calculate the value. 'High' by default.",{context:"pine_docs_args_info"})},{name:"leftbars",type:"series",info:$.t("Left strength.",{context:"pine_docs_args_info"})},{name:"rightbars",type:"series",info:$.t("Right strength.",{context:"pine_docs_args_info"})}],remarks:[$.t("If parameters 'leftbars' or 'rightbars' are series you should use {@fun max_bars_back} function for the 'source' variable.",{context:"pine_docs_remarks"})],examples:['study("PivotHigh", overlay=true)',"leftBars = input(2)","rightBars=input(2)","ph = pivothigh(leftBars, rightBars)","plot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"],syntax:["pivothigh(source, leftbars, rightbars) → series[float]","pivothigh(leftbars, rightbars) → series[float]"]},pivotlow:{kind:"Built-in function",desc:[$.t("This function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point.",{context:"pine_docs_desc"})],returns:[$.t("Price of the point or 'NaN'.",{context:"pine_docs_returns"})],args:[{name:"source",type:"series",info:$.t("An optional parameter. Data series to calculate the value. 'Low' by default.",{context:"pine_docs_args_info"})},{name:"leftbars",type:"series",info:$.t("Left strength.",{context:"pine_docs_args_info"})},{name:"rightbars",type:"series",info:$.t("Right strength.",{context:"pine_docs_args_info"})}],remarks:[$.t("If parameters 'leftbars' or 'rightbars' are series you should use {@fun max_bars_back} function for the 'source' variable.",{context:"pine_docs_remarks"})],examples:['study("PivotLow", overlay=true)',"leftBars = input(2)","rightBars=input(2)","pl = pivotlow(close, leftBars, rightBars)","plot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"],syntax:["pivotlow(source, leftbars, rightbars) → series[float]","pivotlow(leftbars, rightbars) → series[float]"]},"strategy.close_all":{kind:"Built-in function",desc:[$.t("It is a command to exit from current market position making it flat. If there is no open market position by the moment the command is triggered, the command will not come into effect.",{context:"pine_docs_desc"})],args:[{name:"when",type:"bool",info:$.t("An optional parameter. Condition of the command.",{context:"pine_docs_args_info"})},{name:"comment",type:"string",info:$.t("An optional parameter. Additional notes on the order.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("closeAll Demo", overlay=false)','strategy.entry("buy", true, when = open > close)','strategy.close_all(when = open < close, comment = "close all entries")',"plot(strategy.position_size)"],syntax:["strategy.close_all(when, comment, alert_message) → void"]},"strategy.close":{kind:"Built-in function",
desc:[$.t("It is a command to exit from the entry with the specified ID. If there were multiple entry orders with the same ID, all of them are exited at once. If there are no open entries with the specified ID by the moment the command is triggered, the command will not come into effect. The command uses market order. Every entry is closed by a separate market order.",{context:"pine_docs_desc"})],args:[{name:"id",info:$.t("A required parameter. The order identifier. It is possible to close an order by referencing its identifier.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"when",type:"bool",info:$.t("An optional parameter. Condition of the command.",{context:"pine_docs_args_info"})},{name:"qty",type:"float",info:$.t("An optional parameter. Number of contracts/shares/lots/units to exit a trade with. The default value is 'NaN'.",{context:"pine_docs_args_info"})},{name:"qty_percent",type:"float",info:$.t("An optional parameter. Defines the percentage of entered contracts/shares/lots/units to exit a trade with. When its value is not NaN, its priority is higher than that of the 'qty' parameter. Its value can range from 0 to 100. If 'qty' is NaN, the default value of 'qty_percent' is 100.",{context:"pine_docs_args_info"})},{name:"comment",type:"string",info:$.t("An optional parameter. Additional notes on the order.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("closeEntry Demo", overlay=false)','strategy.entry("buy", true, when = open > close)','strategy.close("buy", when = open < close, qty_percent = 50, comment = "close buy entry for 50%")',"plot(strategy.position_size)"],syntax:["strategy.close(id, when, comment, qty, qty_percent, alert_message) → void"]},"strategy.risk.max_position_size":{kind:"Built-in function",desc:[$.t("The purpose of this rule is to determine maximum size of a market position. The rule affects the following function: {@fun strategy.entry}. The 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units, so the total position size doesn't exceed the value specified in 'strategy.risk.max_position_size'. If minimum possible quantity still violates the rule, the order will not be placed.",{context:"pine_docs_desc"})],args:[{name:"contracts",type:"float",info:$.t("A required parameter. Maximum number of contracts/shares/lots/units in a position",{context:"pine_docs_args_info"})}],examples:['strategy("risk.max_position_size Demo", default_qty_value = 100)',"strategy.risk.max_position_size(10)",'strategy.entry("buy", true, when = open > close)',"plot(strategy.position_size)  // max plot value will be 10"],syntax:["strategy.risk.max_position_size(contracts) → void"]},"strategy.risk.max_intraday_loss":{kind:"Built-in function",
desc:[$.t("The purpose of this rule is to determine maximum loss per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum loss value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session.",{context:"pine_docs_desc"})],args:[{name:"value",type:"float",info:$.t("A required parameter. The maximum loss value. It is specified either in money (base currency), or in percentage of maximum intraday equity. For % of equity the range of allowed values is from 0 to 1 (where 1 = 100%).",{context:"pine_docs_args_info"})},{name:"type",type:"string",info:$.t("A required parameter. The type of the value. Please specify one of the following values: {@var strategy.percent_of_equity} or {@var strategy.cash}. Note: if equity drops down to zero or to a negative and the {@var strategy.percent_of_equity} is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("risk.max_intraday_loss Demo 1")',"strategy.risk.max_intraday_loss(10, strategy.percent_of_equity) // set maximum intraday loss to 10% of maximum intraday equity","// ... ",'strategy("risk.max_intraday_loss Demo 2", currency = EUR)',"strategy.risk.max_intraday_loss(100, strategy.cash) // set maximum intraday loss to 100 EUR from maximum intraday equity","// ... "],syntax:["strategy.risk.max_intraday_loss(value, type, alert_message) → void"]},"strategy.risk.max_intraday_filled_orders":{kind:"Built-in function",desc:[$.t("The purpose of this rule is to determine maximum number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum number of filled orders is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session.",{context:"pine_docs_desc"})],args:[{name:"count",type:"float",info:$.t("A required parameter. The maximum number of filled orders per 1 day",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("risk.max_intraday_filled_orders Demo")',"strategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).",'strategy.entry("buy", true, when = open > close)','strategy.entry("sell", false, when = open < close)'],
syntax:["strategy.risk.max_intraday_filled_orders(count, alert_message) → void"]},"strategy.risk.allow_entry_in":{kind:"Built-in function",desc:[$.t("The purpose of this rule is to forbid short entries, only long etries will be placed. The rule affects the following function: 'entry'.",{context:"pine_docs_desc"})],args:[{name:"value",type:"string",info:$.t("To determine allowed market position direction, please specify one of the following values: {@var strategy.direction.all} (by default), {@var strategy.direction.long}, {@var strategy.direction.short}",{context:"pine_docs_args_info"})}],examples:['strategy("risk.long_only Demo")',"strategy.risk.allow_entry_in(strategy.direction.long) // There will be no short entries, only exits from long.",'strategy.entry("buy", true, when = open > close)','strategy.entry("sell", false, when = open < close)'],syntax:["strategy.risk.allow_entry_in(value) → void"]},"strategy.risk.max_cons_loss_days":{kind:"Built-in function",desc:[$.t("The purpose of this rule is to cancel all pending orders, close all open positions and stop placing orders after a specified number of consecutive days with losses. The rule affects the whole strategy.",{context:"pine_docs_desc"})],args:[{name:"count",type:"float",info:$.t("A required parameter. The allowed number of consecutive days with losses.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("risk.max_cons_loss_days Demo 1")',"strategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.","// ..."],syntax:["strategy.risk.max_cons_loss_days(count, alert_message) → void"]},"strategy.risk.max_drawdown":{kind:"Built-in function",desc:[$.t("The purpose of this rule is to determine maximum drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed.",{context:"pine_docs_desc"})],args:[{name:"value",type:"float",info:$.t("A required parameter. The maximum drawdown value. It is specified either in money (base currency), or in percentage of maximum equity. For % of equity the range of allowed values is from 0 to 100.",{context:"pine_docs_args_info"})},{name:"type",type:"string",info:$.t("A required parameter. The type of the value. Please specify one of the following values: {@var strategy.percent_of_equity} or {@var strategy.cash}. Note: if equity drops down to zero or to a negative and the 'strategy.percent_of_equity' is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",{context:"pine_docs_args_info"})},{name:"alert_message",type:"string",
info:$.t('An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the "Create Alert" dialog box\'s "Message" field.',{context:"pine_docs_args_info"})}],examples:['strategy("risk.max_drawdown Demo 1")',"strategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity","// ... ",'strategy("risk.max_drawdown Demo 2", currency = EUR)',"strategy.risk.max_drawdown(2000, strategy.cash)  // set maximum drawdown to 2000 EUR from maximum equity","// ... "],syntax:["strategy.risk.max_drawdown(value, type, alert_message) → void"]},"box.new":{kind:"Built-in function",desc:[$.t("Creates a new box object.",{context:"pine_docs_desc"})],returns:[$.t("The ID of a box object which may be used in box.set_*() and box.get_*() functions.",{context:"pine_docs_returns"})],args:[{name:"left",type:"series[integer]",info:$.t("Bar index (if xloc = {@var xloc.bar_index}) or UNIX time (if xloc = {@var xloc.bar_time}) of the left border of the box. Note that if xloc = {@var xloc.bar_index}, the argument must be less than or equal to the index of the current bar.",{context:"pine_docs_args_info"})},{name:"top",type:"series[float]",info:$.t("Price of the top border of the box.",{context:"pine_docs_args_info"})},{name:"right",type:"series[integer]",info:$.t("Bar index (if xloc = {@var xloc.bar_index}) or UNIX time (if xloc = {@var xloc.bar_time}) of the right border of the box. Note that if xloc = {@var xloc.bar_index}, the argument must be less than or equal to the index of the current bar.",{context:"pine_docs_args_info"})},{name:"bottom",type:"series[float]",info:$.t("Price of the bottom border of the box.",{context:"pine_docs_args_info"})},{name:"border_color",type:"series[color]",info:$.t("Color of the four borders. Optional. The default is {@var color.blue}.",{context:"pine_docs_args_info"})},{name:"border_width",type:"series[integer]",info:$.t("Width of the four borders, in pixels. Optional. The default is 1 pixel.",{context:"pine_docs_args_info"})},{name:"border_style",type:"series[string]",info:$.t("Style of the four borders. Possible values: {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}. Optional. The default value is {@var line.style_solid}.",{context:"pine_docs_args_info"})},{name:"extend",type:"series[string]",info:$.t("When {@var extend.none} is used, the horizontal borders start at the left border and end at the right border. With {@var extend.left} or {@var extend.right}, the horizontal borders are extended indefinitely to the left or right of the box, respectively. With {@var extend.both}, the horizontal borders are extended on both sides. Optional. The default value is {@var extend.none}.",{context:"pine_docs_args_info"})},{name:"xloc",type:"series[string]",
info:$.t("Determines whether the arguments to 'left' and 'right' are a bar index or a time value. If xloc = {@var xloc.bar_index}, the arguments must be a bar index. If xloc = {@var xloc.bar_time}, the arguments must be a UNIX time. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Optional. The default is {@var xloc.bar_index}.",{context:"pine_docs_args_info"})},{name:"bgcolor",type:"series[color]",info:$.t("Background color of the box. Optional. The default is {@var color.blue}.",{context:"pine_docs_args_info"})}],examples:["b = box.new(time, close, time + 24 * 60 * 60 * 1000, 0, color.fuchsia, 2, line.style_dotted, extend.none, xloc.bar_time)","box.set_lefttop(b, time, close)"],seeAlso:["{@fun box.delete}, {@fun box.get_left}, {@fun box.get_top}, {@fun box.get_right}, {@fun box.get_bottom}, {@fun box.set_top_left}, {@fun box.set_left}, {@fun box.set_top}, {@fun box.set_bottom_right}, {@fun box.set_right}, {@fun box.set_bottom}, {@fun box.set_border_color}, {@fun box.set_bgcolor}, {@fun box.set_border_width}, {@fun box.set_border_style}, {@fun box.set_extend}"],syntax:["box.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor) → series[box]"]},"box.delete":{kind:"Built-in function",desc:[$.t("Deletes the specified box object. If it has already been deleted, does nothing.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object to delete.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}"],syntax:["box.delete(id) → void"]},"box.get_left":{kind:"Built-in function",desc:[$.t("Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box.",{context:"pine_docs_desc"})],returns:[$.t("A bar index or a UNIX timestamp (in milliseconds).",{context:"pine_docs_returns"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.set_left}"],syntax:["box.get_left(id) → series[integer]"]},"box.get_right":{kind:"Built-in function",desc:[$.t("Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box.",{context:"pine_docs_desc"})],returns:[$.t("A bar index or a UNIX timestamp (in milliseconds).",{context:"pine_docs_returns"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.set_right}"],syntax:["box.get_right(id) → series[integer]"]},"box.get_top":{kind:"Built-in function",desc:[$.t("Returns the price value of the top border of the box.",{context:"pine_docs_desc"})],returns:[$.t("The price value.",{context:"pine_docs_returns"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.set_top}"],syntax:["box.get_top(id) → series[float]"]},"box.get_bottom":{kind:"Built-in function",desc:[$.t("Returns the price value of the bottom border of the box.",{context:"pine_docs_desc"})],
returns:[$.t("The price value.",{context:"pine_docs_returns"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.set_bottom}"],syntax:["box.get_bottom(id) → series[float]"]},"box.set_left":{kind:"Built-in function",desc:[$.t("Sets the left coordinate of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"left",type:"series[integer]",info:$.t("Bar index or bar time of the left border. Note that if xloc = {@var xloc.bar_index}, the argument must be less than or equal to the index of the current bar.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_left}"],syntax:["box.set_left(id, left) → void"]},"box.set_lefttop":{kind:"Built-in function",desc:[$.t("Sets the left and top coordinates of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"left",type:"series[integer]",info:$.t("Bar index or bar time of the left border.",{context:"pine_docs_args_info"})},{name:"top",type:"series[float]",info:$.t("Price value of the top border.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_left}, {@fun box.get_top}"],syntax:["box.set_lefttop(id, left, top) → void"]},"box.set_right":{kind:"Built-in function",desc:[$.t("Sets the right coordinate of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"right",type:"series[integer]",info:$.t("Bar index or bar time of the right border. Note that if xloc = {@var xloc.bar_index}, then the argument must be less than or equal to the index of the current bar.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_right}"],syntax:["box.set_right(id, right) → void"]},"box.set_rightbottom":{kind:"Built-in function",desc:[$.t("Sets the right and bottom coordinates of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"right",type:"series[integer]",info:$.t("Bar index or bar time of the right border.",{context:"pine_docs_args_info"})},{name:"bottom",type:"series[float]",info:$.t("Price value of the bottom border.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_right}, {@fun box.get_bottom}"],syntax:["box.set_rightbottom(id, right, bottom) → void"]},"box.set_top":{kind:"Built-in function",desc:[$.t("Sets the top coordinate of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"top",type:"series[float]",info:$.t("Price value of the top border.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_top}"],syntax:["box.set_top(id, top) → void"]},"box.set_bottom":{kind:"Built-in function",desc:[$.t("Sets the bottom coordinate of the box.",{context:"pine_docs_desc"})],
args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"bottom",type:"series[float]",info:$.t("Price value of the bottom border.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}, {@fun box.get_bottom}"],syntax:["box.set_bottom(id, bottom) → void"]},"box.set_border_color":{kind:"Built-in function",desc:[$.t("Sets the border color of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"color",type:"series[color]",info:$.t("New border color.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}"],syntax:["box.set_border_color(id, color) → void"]},"box.set_bgcolor":{kind:"Built-in function",desc:[$.t("Sets the background color of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"color",type:"series[color]",info:$.t("New background color.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}"],syntax:["box.set_bgcolor(id, color) → void"]},"box.set_border_width":{kind:"Built-in function",desc:[$.t("Sets the border width of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"width",type:"series[integer]",info:$.t("Width of the four borders, in pixels.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}"],syntax:["box.set_border_width(id, width) → void"]},"box.set_border_style":{kind:"Built-in function",desc:[$.t("Sets the border style of the box.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"style",type:"series[string]",info:$.t("New border style.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}","{@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}"],syntax:["box.set_border_style(id, style) → void"]},"box.set_extend":{kind:"Built-in function",desc:[$.t("Sets extending type of the border of this box object. When {@var extend.none} is used, the horizontal borders start at the left border and end at the right border. With {@var extend.left} or {@var extend.right}, the horizontal borders are extended indefinitely to the left or right of the box, respectively. With {@var extend.both}, the horizontal borders are extended on both sides.",{context:"pine_docs_desc"})],args:[{name:"id",type:"series[box]",info:$.t("A box object.",{context:"pine_docs_args_info"})},{name:"extend",type:"series[string]",info:$.t("New extending type.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun box.new}","{@var extend.none}, {@var extend.right}, {@var extend.left}, {@var extend.both}"],syntax:["box.set_extend(id, extend) → void"]},"line.new":{kind:"Built-in function",desc:[$.t("Creates new line object",{context:"pine_docs_desc"})],returns:[$.t("Line ID object which may be passed to line.setXXX and line.getXXX functions",{context:"pine_docs_returns"})],args:[{name:"x1",type:"series",
info:$.t("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the first point of the line. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})},{name:"y1",type:"series",info:$.t("Price of the first point of the line",{context:"pine_docs_args_info"})},{name:"x2",type:"series",info:$.t("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the second point of the line. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})},{name:"y2",type:"series",info:$.t("Price of the second point of the line",{context:"pine_docs_args_info"})},{name:"xloc",type:"string",info:$.t("See description of {b_on}x1{b_off} argument. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Default is {@var xloc.bar_index}",{context:"pine_docs_args_info"}).format({b_on:"<b>",b_off:"</b>"})},{name:"extend",type:"string",info:$.t("If extend={@var extend.none}, draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to {@var extend.right} or {@var extend.left}, draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend={@var extend.both}, draws a straight line that goes through these points. Default value is {@var extend.none}.",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("Line color",{context:"pine_docs_args_info"})},{name:"style",type:"string",info:$.t("Line style. Possible values: {@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}",{context:"pine_docs_args_info"})},{name:"width",type:"integer",info:$.t("Line width in pixels",{context:"pine_docs_args_info"})}],examples:["var line1 = line.new(0, low, bar_index, high, extend=extend.right)","var line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)","line.set_x2(line1, 0)","line.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)","line.set_color(line2, color.green)","line.set_width(line2, 5)"],seeAlso:["{@fun line.delete}, {@fun line.set_x1}, {@fun line.set_y1}, {@fun line.set_xy1}, {@fun line.set_x2}, {@fun line.set_y2}, {@fun line.set_xy2}, {@fun line.set_xloc}, {@fun line.set_color}, {@fun line.set_extend}, {@fun line.set_style}, {@fun line.set_width}"],syntax:["line.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series[line]"]},"line.set_x1":{kind:"Built-in function",desc:[$.t("Sets bar index or bar time (depending on the xloc) of the first point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("Bar index or bar time. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{
context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_x1(id, x) → void"]},"line.set_y1":{kind:"Built-in function",desc:[$.t("Sets price of the first point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("Price",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_y1(id, y) → void"]},"line.set_xy1":{kind:"Built-in function",desc:[$.t("Sets bar index/time and price of the first point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("Bar index or bar time. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("Price",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_xy1(id, x, y) → void"]},"line.set_x2":{kind:"Built-in function",desc:[$.t("Sets bar index or bar time (depending on the xloc) of the second point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("Bar index or bar time. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_x2(id, x) → void"]},"line.set_y2":{kind:"Built-in function",desc:[$.t("Sets price of the second point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("Price",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_y2(id, y) → void"]},"line.set_xy2":{kind:"Built-in function",desc:[$.t("Sets bar index/time and price of the second point",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("Bar index or bar time",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("Price",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_xy2(id, x, y) → void"]},"line.set_xloc":{kind:"Built-in function",desc:[$.t("Sets x-location and new bar index/time values",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x1",type:"series",info:$.t("Bar index or bar time of the first point",{context:"pine_docs_args_info"})},{name:"x2",type:"series",info:$.t("Bar index or bar time of the second point",{context:"pine_docs_args_info"})},{name:"xloc",type:"string",info:$.t("New x-location value",{context:"pine_docs_args_info"})}],seeAlso:["{@var xloc.bar_index}, {@var xloc.bar_time}, {@fun line.new}"],syntax:["line.set_xloc(id, x1, x2, xloc) → void"]},"line.set_extend":{kind:"Built-in function",
desc:[$.t("Sets extending type of this line object. If extend={@var extend.none}, draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to {@var extend.right} or {@var extend.left}, draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend={@var extend.both}, draws a straight line that goes through these points.",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"extend",type:"string",info:$.t("New extending type",{context:"pine_docs_args_info"})}],seeAlso:["{@var extend.none}, {@var extend.right}, {@var extend.left}, {@var extend.both}, {@fun line.new}"],syntax:["line.set_extend(id, extend) → void"]},"line.set_color":{kind:"Built-in function",desc:[$.t("Sets the line color",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("New line color",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_color(id, color) → void"]},"line.set_style":{kind:"Built-in function",desc:[$.t("Sets the line style",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"style",type:"string",info:$.t("New line style",{context:"pine_docs_args_info"})}],seeAlso:["{@var line.style_solid}, {@var line.style_dotted}, {@var line.style_dashed}, {@var line.style_arrow_left}, {@var line.style_arrow_right}, {@var line.style_arrow_both}, {@fun line.new}"],syntax:["line.set_style(id, style) → void"]},"line.set_width":{kind:"Built-in function",desc:[$.t("Sets the line width",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"width",type:"integer",info:$.t("New line width in pixels",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.set_width(id, width) → void"]},"line.delete":{kind:"Built-in function",desc:[$.t("Deletes the specified line object. If it has already been deleted, does nothing.",{context:"pine_docs_desc"})],args:[{name:"id",type:"line",info:$.t("Line object to delete",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.delete(id) → void"]},"line.get_x1":{kind:"Built-in function",desc:[$.t("Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line",{context:"pine_docs_desc"})],returns:[$.t("UNIX timestamp (in milliseconds) or bar index",{context:"pine_docs_returns"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})}],examples:["my_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)","a = line.get_x1(my_line)","plot(time - line.get_x1(my_line)) //draws zero plot"],seeAlso:["{@fun line.new}"],syntax:["line.get_x1(id) → series[integer]"]},"line.get_y1":{kind:"Built-in function",desc:[$.t("Returns price of the first point of the line",{context:"pine_docs_desc"})],returns:[$.t("Price value",{
context:"pine_docs_returns"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.get_y1(id) → series[float]"]},"line.get_x2":{kind:"Built-in function",desc:[$.t("Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line",{context:"pine_docs_desc"})],returns:[$.t("UNIX timestamp (in milliseconds) or bar index",{context:"pine_docs_returns"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.get_x2(id) → series[integer]"]},"line.get_y2":{kind:"Built-in function",desc:[$.t("Returns price of the second point of the line",{context:"pine_docs_desc"})],returns:[$.t("Price value",{context:"pine_docs_returns"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})}],seeAlso:["{@fun line.new}"],syntax:["line.get_y2(id) → series[float]"]},"line.get_price":{kind:"Built-in function",desc:[$.t("Returns the price level of a line at a given bar index.",{context:"pine_docs_desc"})],returns:[$.t("Price value of line 'id' at bar index 'x'.",{context:"pine_docs_returns"})],args:[{name:"id",type:"line",info:$.t("Line object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("Bar index for which price is required",{context:"pine_docs_args_info"})}],remarks:[$.t("The line is considered to have been created using 'extend=extend.both'.",{context:"pine_docs_remarks"}),$.t("This function can only be called for lines created using 'xloc.bar_index'. If you try to call it for a line created with 'xloc.bar_time', it will generate an error.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("GetPrice", overlay=true)',"var line l = na","if bar_index == 10","    l := line.new(0, high[5], bar_index, high)","plot(line.get_price(l, bar_index), color=color.green)"],seeAlso:["{@fun line.new}"],syntax:["line.get_price(id, x) → series[float]"]},"label.new":{kind:"Built-in function",desc:[$.t("Creates new label object",{context:"pine_docs_desc"})],returns:[$.t("Label ID object which may be passed to label.setXXX and label.getXXX functions",{context:"pine_docs_returns"})],args:[{name:"x",type:"series",info:$.t("Bar index (if xloc = {@var xloc.bar_index}) or bar UNIX time (if xloc = {@var xloc.bar_time}) of the label position. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("Price of the label position. It is taken into account only if yloc={@var yloc.price}",{context:"pine_docs_args_info"})},{name:"text",type:"string",info:$.t("Label text. Default is empty string",{context:"pine_docs_args_info"})},{name:"xloc",type:"string",info:$.t("See description of {b_on}x{b_off} argument. Possible values: {@var xloc.bar_index} and {@var xloc.bar_time}. Default is {@var xloc.bar_index}",{context:"pine_docs_args_info"}).format({b_on:"<b>",b_off:"</b>"})},{name:"yloc",
type:"string",info:$.t("Possible values are {@var yloc.price}, {@var yloc.abovebar}, {@var yloc.belowbar}. If yloc={@var yloc.price}, {b_on}y{b_off} argument specifies the price of the label position. If yloc={@var yloc.abovebar}, label is located above bar. If yloc={@var yloc.belowbar}, label is located below bar. Default is {@var yloc.price}",{context:"pine_docs_args_info"}).format({b_on:"<b>",b_off:"</b>"})},{name:"color",type:"color",info:$.t("Color of the label border and arrow",{context:"pine_docs_args_info"})},{name:"style",type:"string",info:$.t("Label style. Possible values: {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}. Default is {@var label.style_label_down}",{context:"pine_docs_args_info"})},{name:"textcolor",type:"color",info:$.t("Text color",{context:"pine_docs_args_info"})},{name:"size",type:"string",info:$.t("Label size. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default value is {@var size.normal}.",{context:"pine_docs_args_info"})},{name:"textalign",type:"string",info:$.t("Label text alignment. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}. Default value is {@var text.align_center}.",{context:"pine_docs_args_info"})},{name:"tooltip",type:"string",info:$.t("Hover to see tooltip label.",{context:"pine_docs_args_info"})}],examples:['var label1 = label.new(bar_index, low, text="Hello, world!", style=label.style_circle)',"label.set_x(label1, 0)","label.set_xloc(label1, time, xloc.bar_time)","label.set_color(label1, color.red)","label.set_size(label1, size.large)"],seeAlso:["{@fun label.delete}, {@fun label.set_x}, {@fun label.set_y}, {@fun label.set_xy}, {@fun label.set_xloc}, {@fun label.set_yloc}, {@fun label.set_color}, {@fun label.set_textcolor}, {@fun label.set_style}, {@fun label.set_size}, {@fun label.set_textalign}, {@fun label.set_tooltip}"],syntax:["label.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip) → series[label]"]},"label.set_x":{kind:"Built-in function",desc:[$.t("Sets bar index or bar time (depending on the xloc) of the label position",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("New bar index or bar time of the label position. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{
context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_x(id, x) → void"]},"label.set_y":{kind:"Built-in function",desc:[$.t("Sets price of the label position",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("New price of the label position",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_y(id, y) → void"]},"label.set_xy":{kind:"Built-in function",desc:[$.t("Sets bar index/time and price of the label position",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("New bar index or bar time of the label position. Note that if xloc = {@var xloc.bar_index} then value of this argument should be less or equal to the index of current bar.",{context:"pine_docs_args_info"})},{name:"y",type:"series",info:$.t("New price of the label position",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_xy(id, x, y) → void"]},"label.set_xloc":{kind:"Built-in function",desc:[$.t("Sets x-location and new bar index/time value",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"x",type:"series",info:$.t("New bar index or bar time of the label position",{context:"pine_docs_args_info"})},{name:"xloc",type:"string",info:$.t("New x-location value",{context:"pine_docs_args_info"})}],seeAlso:["{@var xloc.bar_index}, {@var xloc.bar_time}, {@fun label.new}"],syntax:["label.set_xloc(id, x, xloc) → void"]},"label.set_yloc":{kind:"Built-in function",desc:[$.t("Sets new y-location calculation algorithm",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"yloc",type:"string",info:$.t("New y-location value",{context:"pine_docs_args_info"})}],seeAlso:["{@var yloc.price}, {@var yloc.abovebar}, {@var yloc.belowbar}, {@fun label.new}"],syntax:["label.set_yloc(id, yloc) → void"]},"label.set_text":{kind:"Built-in function",desc:[$.t("Sets label text",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"text",type:"string",info:$.t("New label text",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_text(id, text) → void"]},"label.set_color":{kind:"Built-in function",desc:[$.t("Sets label border and arrow color",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"color",type:"color",info:$.t("New label border and arrow color",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_color(id, color) → void"]},"label.set_style":{kind:"Built-in function",desc:[$.t("Sets label style",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"style",type:"string",
info:$.t("New label style. Possible values: {@var label.style_none}, {@var label.style_xcross}, {@var label.style_cross}, {@var label.style_triangleup}, {@var label.style_triangledown}, {@var label.style_flag}, {@var label.style_circle}, {@var label.style_arrowup}, {@var label.style_arrowdown}, {@var label.style_label_up}, {@var label.style_label_down}, {@var label.style_label_left}, {@var label.style_label_right}, {@var label.style_label_lower_left}, {@var label.style_label_lower_right}, {@var label.style_label_upper_left}, {@var label.style_label_upper_right}, {@var label.style_label_center}, {@var label.style_square}, {@var label.style_diamond}",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_style(id, style) → void"]},"label.set_textcolor":{kind:"Built-in function",desc:[$.t("Sets color of the label text",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"textcolor",type:"color",info:$.t("New text color",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_textcolor(id, textcolor) → void"]},"label.set_size":{kind:"Built-in function",desc:[$.t("Sets arrow and text size of the specified label object.",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"size",type:"string",info:$.t("Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}. Default value is {@var size.auto}.",{context:"pine_docs_args_info"})}],seeAlso:["{@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}, {@fun label.new}"],syntax:["label.set_size(id, size) → void"]},"label.set_textalign":{kind:"Built-in function",desc:[$.t("Sets the alignment for the label text.",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})},{name:"textalign",type:"string",info:$.t("Label text alignment. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.",{context:"pine_docs_args_info"})}],seeAlso:["{@var text.align_left}, {@var text.align_center}, {@var text.align_right}, {@fun label.new}"],syntax:["label.set_textalign(id, textalign) → void"]},"label.set_tooltip":{kind:"Built-in function",desc:[$.t("Sets the tooltip text.",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object.",{context:"pine_docs_args_info"})},{name:"tooltip",type:"string",info:$.t("Tooltip text.",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.set_tooltip(id, tooltip) → void"]},"label.delete":{kind:"Built-in function",desc:[$.t("Deletes the specified label object. If it has already been deleted, does nothing.",{context:"pine_docs_desc"})],args:[{name:"id",type:"label",info:$.t("Label object to delete",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.delete(id) → void"]},
"label.get_x":{kind:"Built-in function",desc:[$.t("Returns UNIX time or bar index (depending on the last xloc value set) of this label's position",{context:"pine_docs_desc"})],returns:[$.t("UNIX timestamp (in milliseconds) or bar index",{context:"pine_docs_returns"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})}],examples:['my_label = label.new(time, open, text="Open bar text", xloc=xloc.bar_time)',"a = label.get_x(my_label)","plot(time - label.get_x(my_label)) //draws zero plot"],seeAlso:["{@fun label.new}"],syntax:["label.get_x(id) → series[integer]"]},"label.get_y":{kind:"Built-in function",desc:[$.t("Returns price of this label's position",{context:"pine_docs_desc"})],returns:[$.t("Floating point value representing price",{context:"pine_docs_returns"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})}],seeAlso:["{@fun label.new}"],syntax:["label.get_y(id) → series[float]"]},"label.get_text":{kind:"Built-in function",desc:[$.t("Returns the text of this label object",{context:"pine_docs_desc"})],returns:[$.t("String object containing the text of this label",{context:"pine_docs_returns"})],args:[{name:"id",type:"label",info:$.t("Label object",{context:"pine_docs_args_info"})}],examples:['my_label = label.new(time, open, text="Open bar text", xloc=xloc.bar_time)',"a = label.get_text(my_label)",'label.new(time, close, text = a + " new", xloc=xloc.bar_time)'],seeAlso:["{@fun label.new}"],syntax:["label.get_text(id) → series[string]"]},max_bars_back:{kind:"Built-in function",desc:[$.t("Function sets the maximum number of bars that is available for historical reference of a given built-in or user variable. When operator '[]' is applied to a variable - it is a reference to a historical value of that variable.",{context:"pine_docs_desc"}),$.t("",{context:"pine_docs_desc"}),$.t("If an argument of an operator '[]' is a compile time constant value (e.g. 'v[10]', 'close[500]') then there is no need to use 'max_bars_back' function for that variable. Pine Script compiler will use that constant value as history buffer size.",{context:"pine_docs_desc"}),$.t("",{context:"pine_docs_desc"}),$.t("If an argument of an operator '[]' is a value, calculated at runtime (e.g. 'v[i]' where 'i' - is a series variable) then Pine Script attempts to autodetect the history buffer size at runtime. Sometimes it fails and the script crashes at runtime because it eventually refers to historical values that are out of the buffer. In that case you should use 'max_bars_back' to fix that problem manually.",{context:"pine_docs_desc"})],returns:["void"],args:[{name:"var",type:"series, color, bool",info:$.t("Series variable identifier for which history buffer should be resized. Possible values are: 'open', 'high', 'low', 'close', 'volume', 'time', or any user defined variable id.",{context:"pine_docs_args_info"})},{name:"num",type:"integer",
info:$.t("History buffer size which is the number of bars that could be referenced for variable 'var'. This should be a literal integer.",{context:"pine_docs_args_info"})}],remarks:[$.t("At the moment 'max_bars_back' cannot be applied to built-ins like 'hl2', 'hlc3', 'ohlc4'. Please use multiple 'max_bars_back' calls as workaround here (e.g. instead of a single ‘max_bars_bars(hl2, 100)’ call you should call the function twice: ‘max_bars_bars(high, 100), max_bars_bars(low, 100)’).",{context:"pine_docs_remarks"}),$.t("",{context:"pine_docs_remarks"}),$.t("If the {@fun study} or {@fun strategy} 'max_bars_back' parameter is used, all variables in the study are affected. This may result in excessive memory usage and cause runtime problems. When possible (i.e. when the cause is a variable rather than a function), please use the {@fun max_bars_back} function instead.",{context:"pine_docs_remarks"})],examples:["//@version=4","study('My Script')","close_() => close","depth() => 400","d = depth()","v = close_()","max_bars_back(v, 500)","out = if bar_index > 0","\tv[d]","else","\tv","plot(out)"],seeAlso:["Param 'max_bars_back' of {@fun study} and {@fun strategy} functions."],syntax:["max_bars_back(var, num) → void"]},"array.new_float":{kind:"Built-in function",desc:[$.t("The function creates a new array object of float type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_float(size, initial_value) → float[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"float",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_float example")',"length = 5","a = array.new_float(length, close)","plot(array.sum(a) / length)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_color}, {@fun array.new_bool}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.new_int":{kind:"Built-in function",desc:[$.t("The function creates a new array object of int type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_int(size, initial_value) → int[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"integer",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_int example")',"length = 5","a = array.new_int(length, int(close))","plot(array.sum(a) / length)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.new_color":{kind:"Built-in function",
desc:[$.t("The function creates a new array object of color type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_color(size, initial_value) → color[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"color",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_color example")',"length = 5","a = array.new_color(length, color.red)","plot(close, color = array.get(a, 0))"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.new_bool":{kind:"Built-in function",desc:[$.t("The function creates a new array object of bool type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_bool(size, initial_value) → bool[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"bool",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_bool example")',"length = 5","a = array.new_bool(length, close > open)","plot(array.get(a, 0) ? close : open)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.new_string":{kind:"Built-in function",desc:[$.t("The function creates a new array object of string type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_string(size, initial_value) → string[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"string",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_string example")',"length = 5",'a = array.new_string(length, "text")',"label.new(bar_index, close, array.get(a, 0))"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"]},"array.new_line":{kind:"Built-in function",desc:[$.t("The function creates a new array object of line type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_line(size, initial_value) → line[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"line",
info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_line example")',"// draw last 15 lines","var a = array.new_line()","array.push(a, line.new(bar_index - 1, close[1], bar_index, close))","if array.size(a) > 15","\tln = array.shift(a)","\tline.delete(ln)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"]},"array.new_box":{kind:"Built-in function",desc:[$.t("The function creates a new array object of box type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_box(size, initial_value) → box[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"box",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.new_box example")','study("My Script")',"box[] boxes = array.new_box()","array.push(boxes, box.new(time, close, time+2, low))","plot(1)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"]},"array.new_table":{kind:"Built-in function",desc:[$.t("The function creates a new array object of table type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_table(size, initial_value) → table[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"table",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],examples:["study('table array')","table[] tables = array.new_table()","array.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)","plot(1)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"]},"array.new_label":{kind:"Built-in function",desc:[$.t("The function creates a new array object of label type elements.",{context:"pine_docs_desc"})],returns:[$.t("The ID of an array object which may be used in other array.*() functions.",{context:"pine_docs_returns"})],syntax:["array.new_label(size, initial_value) → label[]"],args:[{name:"size",type:"integer",info:$.t("Initial size of an array.",{context:"pine_docs_args_info"})},{name:"initial_value",type:"label",info:$.t("Initial value of all array elements.",{context:"pine_docs_args_info"})}],
examples:["//@version=4",'study("array.new_label example")',"var a = array.new_label()",'l = label.new(bar_index, close, "some text")',"array.push(a, l)","if close > close[1] and close[1] > close[2]","\t// remove all labels","\tsize = array.size(a) - 1","\tfor i = 0 to size","\t\tlb = array.get(a, i)","\t\tlabel.delete(lb)"],remarks:[$.t("An array index starts from 0.",{context:"pine_docs_remarks"})],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"]},"array.copy":{kind:"Built-in function",desc:[$.t("The function creates a copy of an existing array.",{context:"pine_docs_desc"})],returns:[$.t("A copy of an array.",{context:"pine_docs_returns"})],syntax:["array.copy(id) → float[]","array.copy(id) → int[]","array.copy(id) → color[]","array.copy(id) → bool[]","array.copy(id) → string[]","array.copy(id) → line[]","array.copy(id) → label[]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.copy example")',"length = 5","a = array.new_float(length, close)","b = array.copy(a)","a := array.new_float(length, open)","plot(array.sum(a) / length)","plot(array.sum(b) / length)"],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.slice":{kind:"Built-in function",desc:[$.t("The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays.",{context:"pine_docs_desc"})],returns:[$.t("A shallow copy of an array's slice.",{context:"pine_docs_returns"})],syntax:["array.slice(id, index_from, index_to) → array"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"index_from",type:"integer",info:$.t("Zero-based index at which to begin extraction.",{context:"pine_docs_args_info"})},{name:"index_to",type:"integer",info:$.t("Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.slice example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","// take elements from 0 to 4","// *note that changes in slice also modify original array ","slice = array.slice(a, 0, 5)","plot(array.sum(a) / 10)","plot(array.sum(slice) / 5)"],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}, {@fun array.sort}"]},"array.size":{kind:"Built-in function",desc:[$.t("The function returns the number of elements in an array.",{context:"pine_docs_desc"})],returns:[$.t("The number of elements in the array.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],
examples:["//@version=4",'study("array.size example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","// note that changes in slice also modify original array","slice = array.slice(a, 0, 5)","array.push(slice, open)","// size was changed in slice and in original array","plot(array.size(a))","plot(array.size(slice))"],seeAlso:["{@fun array.new_float}, {@fun array.sum}, {@fun array.slice}, {@fun array.sort}"],syntax:["array.size(id) → series[integer]"]},"array.get":{kind:"Built-in function",desc:[$.t("The function returns the value of the element at the specified index.",{context:"pine_docs_desc"})],returns:[$.t("The array element's value.",{context:"pine_docs_returns"})],syntax:["array.get(id, index) → series[float]","array.get(id, index) → series[int]","array.get(id, index) → series[color]","array.get(id, index) → series[bool]","array.get(id, index) → series[string]","array.get(id, index) → series[line]","array.get(id, index) → series[label]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"index",type:"integer",info:$.t("The index of the element whose value is to be returned.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.get example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i] - open[i])","plot(array.get(a, 9))"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.slice}, {@fun array.sort}"]},"array.min":{kind:"Built-in function",desc:[$.t("The function returns the lowest value from a given array.",{context:"pine_docs_desc"})],returns:[$.t("The lowest value in the array.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.min example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.min(a))"],seeAlso:["{@fun array.new_float}, {@fun array.max}, {@fun array.sum}"],syntax:["array.min(id) → series[float]","array.min(id) → series[integer]"]},"array.max":{kind:"Built-in function",desc:[$.t("The function returns the largest value from a given array.",{context:"pine_docs_desc"})],returns:[$.t("The largest value in the array.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.max example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.max(a))"],seeAlso:["{@fun array.new_float}, {@fun array.min}, {@fun array.sum}"],syntax:["array.max(id) → series[float]","array.max(id) → series[integer]"]},"array.range":{kind:"Built-in function",desc:[$.t("The function returns the difference between the min and max values from a given array.",{context:"pine_docs_desc"})],
returns:[$.t("The difference between the min and max values in the array.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.range example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.range(a))"],seeAlso:["{@fun array.new_float}, {@fun array.min}, {@fun array.max}, {@fun array.sum}"],syntax:["array.range(id) → series[float]","array.range(id) → series[integer]"]},"array.sum":{kind:"Built-in function",desc:[$.t("The function returns the sum of an array's elements.",{context:"pine_docs_desc"})],returns:[$.t("The sum of the array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.sum example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.sum(a))"],seeAlso:["{@fun array.new_float}, {@fun array.max}, {@fun array.min}"],syntax:["array.sum(id) → series[float]","array.sum(id) → series[integer]"]},"array.set":{kind:"Built-in function",desc:[$.t("The function sets the value of the element at the specified index.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"index",type:"integer",info:$.t("The index of the element to be modified.",{context:"pine_docs_args_info"})},{name:"value",type:"float, string, label, line",info:$.t("The new value to be set.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.set example")',"a = array.new_float(10)","for i = 0 to 9","\tarray.set(a, i, close[i])","plot(array.sum(a) / 10)"],seeAlso:["{@fun array.new_float}, {@fun array.get}, {@fun array.slice}"],syntax:["array.set(id, index, value) → void"]},"array.from":{kind:"Built-in function",desc:[$.t("The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, and returns an array of the corresponding type.",{context:"pine_docs_desc"})],args:[{name:"arg0, arg1, ...",type:"const  (const int, float, bool, string, label, line, color, box, table)",info:$.t("Array arguments.",{context:"pine_docs_args_info"})}],syntax:["array.from(..args) → int[]","array.from(..args) → bool[]","array.from(..args) → color[]","array.from(..args) → float[]","array.from(..args) → line[]","array.from(..args) → label[]","array.from(..args) → box[]","array.from(..args) → table[]","array.from(..args) → string[]"],returns:[$.t("The array element's value.",{context:"pine_docs_returns"})],examples:["//@version=4",'study("array.from_example", overlay = false)','arr = array.from("Hello", "World!") // arr (string[]) will contain 2 elements: {Hello}, {World!}.',"plot(close)"]},"array.fill":{kind:"Built-in function",
desc:[$.t("The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float, string, label, line",info:$.t("Value to fill the array with.",{context:"pine_docs_args_info"})},{name:"index_from",type:"integer",info:$.t("Start index, default is 0.",{context:"pine_docs_args_info"})},{name:"index_to",type:"integer",info:$.t("End index, default is na. Must be one greater than the index of the last element to set.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.fill example")',"a = array.new_float(10)","array.fill(a, close)","plot(array.sum(a))"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.slice}"],syntax:["array.fill(id, value, index_from, index_to) → void"]},"array.insert":{kind:"Built-in function",desc:[$.t("The function changes the contents of an array by adding new elements in place.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"index",type:"integer",info:$.t("The index at which to insert the value.",{context:"pine_docs_args_info"})},{name:"value",type:"float, string, label, line",info:$.t("The value to add to the array.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.insert example")',"a = array.new_float(5, close)","array.insert(a, 0, open)","plot(array.get(a, 5))"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],syntax:["array.insert(id, index, value) → void"]},"array.join":{kind:"Built-in function",desc:[$.t("The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"separator",type:"string",info:$.t("The string used to separate each array element.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.join example")',"a = array.new_float(5, 5)",'label.new(bar_index, close, array.join(a, ","))'],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],syntax:["array.join(id, separator) → series[string]"]},"array.push":{kind:"Built-in function",desc:[$.t("The function appends a value to an array.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float, string, label, line",info:$.t("The value of the element added to the end of the array.",{context:"pine_docs_args_info"})}],
examples:["//@version=4",'study("array.push example")',"a = array.new_float(5, 0)","array.push(a, open)","plot(array.get(a, 5))"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.pop}, {@fun array.unshift}"],syntax:["array.push(id, value) → void"]},"array.remove":{kind:"Built-in function",desc:[$.t("The function changes the contents of an array by removing the element with the specified index.",{context:"pine_docs_desc"})],returns:[$.t("The value of the removed element.",{context:"pine_docs_returns"})],syntax:["array.remove(id, index) → series[float]","array.remove(id, index) → series[int]","array.remove(id, index) → series[color]","array.remove(id, index) → series[bool]","array.remove(id, index) → series[string]","array.remove(id, index) → series[line]","array.remove(id, index) → series[label]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"index",type:"integer",info:$.t("The index of the element to remove.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.remove example")',"a = array.new_float(5,high)","removedEl = array.remove(a, 0)","plot(array.size(a))","plot(removedEl)"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.insert}, {@fun array.pop}, {@fun array.shift}"]},"array.pop":{kind:"Built-in function",desc:[$.t("The function removes the last element from an array and returns its value.",{context:"pine_docs_desc"})],returns:[$.t("The value of the removed element.",{context:"pine_docs_returns"})],syntax:["array.pop(id) → series[float]","array.pop(id) → series[int]","array.pop(id) → series[color]","array.pop(id) → series[bool]","array.pop(id) → series[string]","array.pop(id) → series[line]","array.pop(id) → series[label]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.pop example")',"a = array.new_float(5,high)","removedEl = array.pop(a)","plot(array.size(a))","plot(removedEl)"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.insert}, {@fun array.shift}"]},"array.clear":{kind:"Built-in function",desc:[$.t("The function removes all elements from an array.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.clear example")',"a = array.new_float(5,high)","array.clear(a)","array.push(a, close)","plot(array.get(a,0))","plot(array.size(a))"],seeAlso:["{@fun array.new_float}, {@fun array.insert}, {@fun array.push}, {@fun array.remove}, {@fun array.pop}"],syntax:["array.clear(id) → void"]},"array.sort":{kind:"Built-in function",desc:[$.t("The function sorts the elements of an array.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"order",type:"bool",info:$.t("The sort order: order.ascending (default) or order.descending.",{
context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.sort example")',"a = array.new_float(0,0)","for i = 0 to 5","\tarray.push(a, high[i])","array.sort(a, order.descending)","if barstate.islast","\tlabel.new(bar_index, close, tostring(a))"],seeAlso:["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice}, {@fun array.reverse}, {@var order.ascending}, {@var order.descending}"],syntax:["array.sort(id, order) → void"]},"array.concat":{kind:"Built-in function",desc:[$.t("The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array.",{context:"pine_docs_desc"})],returns:[$.t("The first array with merged elements from the second array.",{context:"pine_docs_returns"})],syntax:["array.concat(id1, id2) → id1"],args:[{name:"id1",type:"array",info:$.t("The first array object.",{context:"pine_docs_args_info"})},{name:"id2",type:"array",info:$.t("The second array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.concat example")',"a = array.new_float(0,0)","b = array.new_float(0,0)","for i = 0 to 4","    array.push(a, high[i])","    array.push(b, low[i])","c = array.concat(a,b)","plot(array.size(a))","plot(array.size(b))","plot(array.size(c))"],seeAlso:["{@fun array.new_float}, {@fun array.insert}, {@fun array.slice},"]},"array.avg":{kind:"Built-in function",desc:[$.t("The function returns the mean of an array's elements.",{context:"pine_docs_desc"})],returns:[$.t("Mean of array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.avg example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.avg(a))"],seeAlso:["{@fun array.new_float}, {@fun array.max}, {@fun array.min}, {@fun array.stdev}"],syntax:["array.avg(id) → series[float]","array.avg(id) → series[integer]"]},"array.stdev":{kind:"Built-in function",desc:[$.t("The function returns the standard deviation of an array's elements.",{context:"pine_docs_desc"})],returns:[$.t("The standard deviation of the array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.stdev example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.stdev(a))"],seeAlso:["{@fun array.new_float}, {@fun array.max}, {@fun array.min}, {@fun array.avg}"],syntax:["array.stdev(id) → series[float]","array.stdev(id) → series[integer]"]},"array.variance":{kind:"Built-in function",desc:[$.t("The function returns the variance of an array's elements.",{context:"pine_docs_desc"})],
returns:[$.t("The variance of the array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.variance example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.variance(a))"],seeAlso:["{@fun array.new_float}, {@fun array.stdev}, {@fun array.min}, {@fun array.avg}, {@fun array.covariance}"],syntax:["array.variance(id) → series[float]","array.variance(id) → series[integer]"]},"array.covariance":{kind:"Built-in function",desc:[$.t("The function returns the covariance of two arrays.",{context:"pine_docs_desc"})],returns:[$.t("The covariance of two arrays.",{context:"pine_docs_returns"})],args:[{name:"id1",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"id2",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.covariance example")',"a = array.new_float(0)","b = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","\tarray.push(a, open[i])","plot(array.covariance(a, b))"],seeAlso:["{@fun array.new_float}, {@fun array.max}, {@fun array.stdev}, {@fun array.avg}, {@fun array.variance}"],syntax:["array.covariance(id1, id2) → series[float]"]},"array.mode":{kind:"Built-in function",desc:[$.t("The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value.",{context:"pine_docs_desc"})],returns:[$.t("The mode of the array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.mode example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.mode(a))"],seeAlso:["{@fun array.new_float}, {@fun array.mode}, {@fun array.avg}, {@fun array.variance}, {@fun array.min}"],syntax:["array.mode(id) → series[float]","array.mode(id) → series[integer]"]},"array.median":{kind:"Built-in function",desc:[$.t("The function returns the median of an array's elements.",{context:"pine_docs_desc"})],returns:[$.t("The median of the array's elements.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.median example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.median(a))"],seeAlso:["{@fun array.median}, {@fun array.avg}, {@fun array.variance}, {@fun array.min}"],syntax:["array.median(id) → series[float]","array.median(id) → series[integer]"]},
"array.standardize":{kind:"Built-in function",desc:[$.t("The function returns the array of standardized elements.",{context:"pine_docs_desc"})],returns:[$.t("The array of standardized elements.",{context:"pine_docs_returns"})],syntax:["array.standardize(id) → float[]","array.standardize(id) → int[]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],remarks:[$.t("The function requires a float or integer array.",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("array.standardize example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","b = array.standardize(a)","plot(array.min(b))","plot(array.max(b))"],seeAlso:["{@fun array.max}, {@fun array.min}, {@fun array.mode}, {@fun array.avg}, {@fun array.variance}, {@fun array.stdev}"]},"array.indexof":{kind:"Built-in function",desc:[$.t("The function returns the index of the first occurrence of the value, or -1 if the value is not found.",{context:"pine_docs_desc"})],returns:[$.t("The index of an element.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float",info:$.t("The value to search in the array.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.indexof example")',"a = array.new_float(5,high)","index = array.indexof(a, high)","plot(index)"],seeAlso:["{@fun array.lastindexof}, {@fun array.get}, {@fun array.lastindexof}, {@fun array.remove}, {@fun array.insert}"],syntax:["array.indexof(id, value) → series[integer]"]},"array.lastindexof":{kind:"Built-in function",desc:[$.t("The function returns the index of the last occurrence of the value, or -1 if the value is not found.",{context:"pine_docs_desc"})],returns:[$.t("The index of an element.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float",info:$.t("The value to search in the array.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.lastindexof example")',"a = array.new_float(5,high)","index = array.lastindexof(a, high)","plot(index)"],seeAlso:["{@fun array.new_float}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.insert}"],syntax:["array.lastindexof(id, value) → series[integer]"]},"array.includes":{kind:"Built-in function",desc:[$.t("The function returns true if the value was found in an array, false otherwise.",{context:"pine_docs_desc"})],returns:[$.t("True if the value was found in the array, false otherwise.",{context:"pine_docs_returns"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float",info:$.t("The value to search in the array.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.includes example")',"a = array.new_float(5,high)","p = close","if array.includes(a, high)","\tp := open","plot(p)"],
seeAlso:["{@fun array.new_float}, {@fun array.indexof}, {@fun array.shift}, {@fun array.remove}, {@fun array.insert}"],syntax:["array.includes(id, value) → series[bool]"]},"array.shift":{kind:"Built-in function",desc:[$.t("The function removes an array's first element and returns its value.",{context:"pine_docs_desc"})],returns:[$.t("The value of the removed element.",{context:"pine_docs_returns"})],syntax:["array.shift(id) → series[float]","array.shift(id) → series[int]","array.shift(id) → series[color]","array.shift(id) → series[bool]","array.shift(id) → series[string]","array.shift(id) → series[line]","array.shift(id) → series[label]"],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.shift example")',"a = array.new_float(5,high)","removedEl = array.shift(a)","plot(array.size(a))","plot(removedEl)"],seeAlso:["{@fun array.unshift}, {@fun array.set}, {@fun array.push}, {@fun array.remove}, {@fun array.includes}"]},"array.unshift":{kind:"Built-in function",desc:[$.t("The function inserts the value at the beginning of the array.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})},{name:"value",type:"float",info:$.t("The value to add to the start of the array.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.unshift example")',"a = array.new_float(5, 0)","array.unshift(a, open)","plot(array.get(a, 0))"],seeAlso:["{@fun array.shift}, {@fun array.set}, {@fun array.insert}, {@fun array.remove}, {@fun array.indexof}"],syntax:["array.unshift(id, value) → void"]},"array.reverse":{kind:"Built-in function",desc:[$.t("The function reverses an array. The first array element becomes the last, and the last array element becomes the first.",{context:"pine_docs_desc"})],args:[{name:"id",type:"array",info:$.t("An array object.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("array.reverse example")',"a = array.new_float(0)","for i = 0 to 9","\tarray.push(a, close[i])","plot(array.get(a, 0))","array.reverse(a)","plot(array.get(a, 0))"],seeAlso:["{@fun array.new_float}, {@fun array.sort}, {@fun array.push}, {@fun array.set}, {@fun array.avg}"],syntax:["array.reverse(id) → void"]},alert:{kind:"Built-in function",desc:[$.t("Triggers an alert event when called during the real-time bar and an alert based on alert function events was previously created for the study or strategy through the “Create Alert” dialog box.",{context:"pine_docs_desc"})],args:[{name:"message",info:$.t("Message sent when the alert triggers. Required argument.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"freq",type:"input string",
info:$.t("The triggering frequency. Possible values are: {@var alert.freq_all} (all function calls trigger the alert), {@var alert.freq_once_per_bar} (the first function call during the bar triggers the alert), {@var alert.freq_once_per_bar_close} (the function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes). The default is {@var alert.freq_once_per_bar}.",{context:"pine_docs_args_info"})}],examples:["//@version=4",'study("`alert()` example", "", true)',"ma = sma(close, 14)","xUp = crossover(close, ma)","if xUp","    // Trigger the alert the first time a cross occurs during the real-time bar.",'    alert("Price (" + tostring(close) + ") crossed over MA (" + tostring(ma) +  ").", alert.freq_once_per_bar)',"plot(ma)",'plotchar(xUp, "xUp", "▲", location.top, size = size.tiny)'],remarks:[$.t("The {html_markup_1}Help Center{html_markup_2} explains how to create such alerts.",{context:"pine_docs_remarks"}).format({html_markup_1:'<a target="blank" href="https://www.tradingview.com/chart/?solution=43000597494">',html_markup_2:"</a>"}),$.t("Contrary to {@fun alertcondition}, {@fun alert} calls do NOT count as an additional plot.",{context:"pine_docs_remarks"}),$.t("Function calls can be located in both global and local scopes.",{context:"pine_docs_remarks"}),$.t("Function calls do not display anything on the chart.",{context:"pine_docs_remarks"}),$.t("The ‘freq‘ argument only affects the triggering frequency of the function call where it is used.",{context:"pine_docs_remarks"})],seeAlso:["{@fun alertcondition}"],syntax:["alert(message, freq) → void"]},earnings:{kind:"Built-in function",desc:[$.t("Requests earnings data for the specified symbol.",{context:"pine_docs_desc"})],args:[{name:"ticker",type:"string",info:$.t('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.',{context:"pine_docs_args_info"})},{name:"field",type:"string",info:$.t("Input string. Possible values include: {@var earnings.actual}, {@var earnings.estimate}. Default value is {@var earnings.actual}.",{context:"pine_docs_args_info"})},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.",{context:"pine_docs_args_info"})},{name:"lookahead",type:"const bool",
info:$.t("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series, or n/a if there is no earnings data for the specified symbol.",{context:"pine_docs_returns"})],examples:['s1 = earnings("NASDAQ:BELFA")',"plot(s1)",'s2 = earnings("NASDAQ:BELFA", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)',"plot(s2)"],seeAlso:["{@fun dividends}, {@fun splits}, {@var security}, {@var syminfo.tickerid}"],syntax:["earnings(ticker, field, gaps, lookahead) → series[float]"]},dividends:{kind:"Built-in function",desc:[$.t("Requests dividends data for the specified symbol.",{context:"pine_docs_desc"})],args:[{name:"ticker",type:"string",info:$.t('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.',{context:"pine_docs_args_info"})},{name:"field",type:"string",info:$.t("Input string. Possible values include: {@var dividends.net}, {@var dividends.gross}. Default value is {@var dividends.gross}.",{context:"pine_docs_args_info"})},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.",{context:"pine_docs_args_info"})},{name:"lookahead",type:"const bool",info:$.t("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series, or n/a if there is no dividends data for the specified symbol.",{context:"pine_docs_returns"})],examples:['s1 = dividends("NASDAQ:BELFA")',"plot(s1)",'s2 = dividends("NASDAQ:BELFA", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)',"plot(s2)"],seeAlso:["{@fun earnings}, {@fun splits}, {@var security}, {@var syminfo.tickerid}"],syntax:["dividends(ticker, field, gaps, lookahead) → series[float]"]},splits:{kind:"Built-in function",desc:[$.t("Requests splits data for the specified symbol.",{context:"pine_docs_desc"})],args:[{name:"ticker",type:"string",info:$.t('Symbol. Note that the symbol should be passed with a prefix. For example: "NASDAQ:AAPL" instead of "AAPL". Using {@var syminfo.ticker} will cause an error. Use {@var syminfo.tickerid} instead.',{
context:"pine_docs_args_info"})},{name:"field",type:"string",info:$.t("Input string. Possible values include: {@var splits.denominator}, {@var splits.numerator}.",{context:"pine_docs_args_info"})},{name:"gaps",type:"const bool",info:$.t("Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: {@var barmerge.gaps_on}, {@var barmerge.gaps_off}. {@var barmerge.gaps_on} - requested data is merged with possible gaps ({@var na} values). {@var barmerge.gaps_off} - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is {@var barmerge.gaps_off}.",{context:"pine_docs_args_info"})},{name:"lookahead",type:"const bool",info:$.t("Merge strategy for the requested data position. Possible values: {@var barmerge.lookahead_on}, {@var barmerge.lookahead_off}. Default value is {@var barmerge.lookahead_off} starting from version 3. Note that behavour is the same on real-time, and differs only on history.",{context:"pine_docs_args_info"})}],returns:[$.t("Requested series, or n/a if there is no splits data for the specified symbol.",{context:"pine_docs_returns"})],examples:['s1 = splits("NASDAQ:BELFA", splits.denominator)',"plot(s1)",'s2 = splits("NASDAQ:BELFA", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)',"plot(s2)"],seeAlso:["{@fun earnings}, {@fun dividends}, {@var security}, {@var syminfo.tickerid}"],syntax:["splits(ticker, field, gaps, lookahead) → series[float]"]},"table.new":{kind:"Built-in function",desc:[$.t("The function creates a new table.",{context:"pine_docs_desc"})],args:[{name:"position",info:$.t("Position of the table. Possible values are: {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}, {@var position.bottom_right}.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"columns",info:$.t("The number of columns in the table.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"rows",info:$.t("The number of rows in the table.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"bgcolor",info:$.t("The background color of the table. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"},{name:"frame_color",info:$.t("The color of the outer frame of the table. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"},{name:"frame_width",info:$.t("The width of the outer frame of the table. Optional. The default is 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"border_color",info:$.t("The color of the borders of the cells (excluding the outer frame). Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"},{name:"border_width",
info:$.t("The width of the borders of the cells (excluding the outer frame). Optional. The default is 0.",{context:"pine_docs_args_info"}),type:"series[integer]"}],returns:[$.t("The ID of a table object that can be passed to other table.*() functions.",{context:"pine_docs_returns"})],remarks:[$.t("This function creates the table object itself, but the table will not be displayed until its cells are populated. To define a cell and change its contents or attributes, use {@fun table.cell} and other table.cell_*() functions.",{context:"pine_docs_remarks"}),$.t("One {@fun table.new} call can only display one table (the last one drawn), but the function itself will be recalculated on each bar it is used on. For performance reasons, it is wise to use {@fun table.new} in conjunction with either the {@op var} keyword (so the table object is only created on the first bar) or in an {@op if} {@var barstate.islast} block (so the table object is only created on the last bar).",{context:"pine_docs_remarks"})],examples:["//@version=4",'study("table.new example")',"var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)","if barstate.islast",'    table.cell(table_id = testTable, column = 0, row = 0, text = "Open is " + tostring(open))','    table.cell(table_id = testTable, column = 1, row = 0, text = "Close is " + tostring(close), bgcolor=color.teal)'],seeAlso:["{@fun table.cell}, {@fun table.clear}, {@fun table.delete}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_position}"],syntax:["table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width) → series[table]"]},"table.delete":{kind:"Built-in function",desc:[$.t("The function deletes a table.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"}],examples:["//@version=4",'study("table.delete example")',"var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)","if barstate.islast",'    table.cell(table_id = testTable, column = 0, row = 0, text = "Open is " + tostring(open))','    table.cell(table_id = testTable, column = 1, row = 0, text = "Close is " + tostring(close), bgcolor=color.teal)',"if barstate.isrealtime","    table.delete(testTable)"],seeAlso:["{@fun table.new}, {@fun table.clear}"],syntax:["table.delete(table_id) → void"]},"table.set_position":{kind:"Built-in function",desc:[$.t("The function sets the position of a table.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"position",
info:$.t("Position of the table. Possible values are: {@var position.top_left}, {@var position.top_center}, {@var position.top_right}, {@var position.middle_left}, {@var position.middle_center}, {@var position.middle_right}, {@var position.bottom_left}, {@var position.bottom_center}, {@var position.bottom_right}.",{context:"pine_docs_args_info"}),type:"series[string]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}"],syntax:["table.set_position(table_id, position) → void"]},"table.set_bgcolor":{kind:"Built-in function",desc:[$.t("The function sets the background color of a table.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"bgcolor",info:$.t("The background color of the table. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_position}"],syntax:["table.set_bgcolor(table_id, bgcolor) → void"]},"table.set_frame_color":{kind:"Built-in function",desc:[$.t("The function sets the color of the outer frame of a table.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"frame_color",info:$.t("The color of the frame of the table. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_border_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_frame_width}, {@fun table.set_position}"],syntax:["table.set_frame_color(table_id, frame_color) → void"]},"table.set_border_color":{kind:"Built-in function",desc:[$.t("The function sets the color of the borders (excluding the outer frame) of the table's cells.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"border_color",info:$.t("The color of the borders. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_frame_width}, {@fun table.set_position}"],syntax:["table.set_border_color(table_id, border_color) → void"]},"table.set_frame_width":{kind:"Built-in function",desc:[$.t("The function set the width of the outer frame of a table.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"frame_width",
info:$.t("The width of the outer frame of the table. Optional. The default is 0.",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_border_width}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_position}"],syntax:["table.set_frame_width(table_id, frame_width) → void"]},"table.set_border_width":{kind:"Built-in function",desc:[$.t("The function sets the width of the borders (excluding the outer frame) of the table's cells.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"border_width",info:$.t("The width of the borders. Optional. The default is 0.",{context:"pine_docs_args_info"}),type:"series[integer]"}],seeAlso:["{@fun table.clear}, {@fun table.delete}, {@fun table.new}, {@fun table.set_frame_color}, {@fun table.set_frame_width}, {@fun table.set_bgcolor}, {@fun table.set_border_color}, {@fun table.set_position}"],syntax:["table.set_border_width(table_id, border_width) → void"]},"table.cell":{kind:"Built-in function",desc:[$.t("The function defines a cell in the table and sets its attributes.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text",info:$.t("The text to be displayed inside the cell. Optional. The default is empty string.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"width",info:$.t("The width of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"height",info:$.t("The height of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.",{context:"pine_docs_args_info"}),type:"series[float]"},{name:"text_color",info:$.t("The color of the text. Optional. The default is {@var color.black}.",{context:"pine_docs_args_info"}),type:"series[color]"},{name:"text_halign",info:$.t("The horizontal alignment of the cell's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"text_valign",info:$.t("The vertical alignment of the cell's text. Optional. The default value is {@var text.align_center}. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"text_size",
info:$.t("The size of the text. An optional parameter, the default value is {@var size.normal}. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.",{context:"pine_docs_args_info"}),type:"series[string]"},{name:"bgcolor",info:$.t("The background color of the text. Optional. The default is no color.",{context:"pine_docs_args_info"}),type:"series[color]"}],remarks:[$.t("This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with {@fun table.new}.",{context:"pine_docs_remarks"}),$.t("Each {@fun table.cell} call overwrites all previously defined properties of a cell. If you call {@fun table.cell} twice in a row, e.g., the first time with text='Test Text', and the second time with text_color={@var color.red} but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string. If you want, instead, to modify any of the cell's properties, use the table.cell_set_*() functions.",{context:"pine_docs_remarks"}),$.t("A single script can only display one table in each of the possible locations. If {@fun table.cell} is used on several bars to change the same attribute of a cell (e.g. change the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow. Avoid unnecessary setting of cell properties by enclosing function calls in an {@op if} {@var barstate.islast} block whenever possible, to restrict their execution to the last bar of the series.",{context:"pine_docs_remarks"})],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor) → void"]},"table.cell_set_text":{kind:"Built-in function",desc:[$.t("The function sets the text in the specified cell.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text",info:$.t("The text to be displayed inside the cell.",{context:"pine_docs_args_info"}),type:"series[string]"}],
examples:["//@version=4",'study("TABLE example")',,"var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)",'table.cell(tLog, row = 0, column = 0, text = "sometext", text_color = color.blue)','table.cell_set_text(tLog, row = 0, column = 0, text = "sometext")'],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_text(table_id, column, row, text) → void"]},"table.cell_set_width":{kind:"Built-in function",desc:[$.t("The function sets the width of the cell",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"width",info:$.t("The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.",{context:"pine_docs_args_info"}),type:"series[float]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}"],syntax:["table.cell_set_width(table_id, column, row, width) → void"]},"table.cell_set_height":{kind:"Built-in function",desc:[$.t("The function sets the height of cell.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"height",info:$.t("The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.",{context:"pine_docs_args_info"}),type:"series[float]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_height(table_id, column, row, height) → void"]},"table.cell_set_text_color":{kind:"Built-in function",desc:[$.t("The function sets the color of the text inside the cell.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",
info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text_color",info:$.t("The color of the text.",{context:"pine_docs_args_info"}),type:"series[color]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_text_color(table_id, column, row, text_color) → void"]},"table.cell_set_text_halign":{kind:"Built-in function",desc:[$.t("The function sets the horizontal alignment of the cell's text.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text_halign",info:$.t("The horizontal alignment of a cell's text. Possible values: {@var text.align_left}, {@var text.align_center}, {@var text.align_right}.",{context:"pine_docs_args_info"}),type:"series[string]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_text_halign(table_id, column, row, text_halign) → void"]},"table.cell_set_text_valign":{kind:"Built-in function",desc:[$.t("The function sets the vertical alignment of a cell's text.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text_valign",info:$.t("The vertical alignment of the cell's text. Possible values: {@var text.align_top}, {@var text.align_center}, {@var text.align_bottom}.",{context:"pine_docs_args_info"}),type:"series[string]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_width}"],syntax:["table.cell_set_text_valign(table_id, column, row, text_valign) → void"]},"table.cell_set_text_size":{kind:"Built-in function",desc:[$.t("The function sets the size of the cell's text.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{
name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"text_size",info:$.t("The size of the text. Possible values: {@var size.auto}, {@var size.tiny}, {@var size.small}, {@var size.normal}, {@var size.large}, {@var size.huge}.",{context:"pine_docs_args_info"}),type:"series[string]"}],seeAlso:["{@fun table.cell_set_bgcolor}, {@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_text_size(table_id, column, row, text_size) → void"]},"table.cell_set_bgcolor":{kind:"Built-in function",desc:[$.t("The function sets the background color of the cell.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"column",info:$.t("The index of the cell's column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"row",info:$.t("The index of the cell's row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"bgcolor",info:$.t("The background color of the cell.",{context:"pine_docs_args_info"}),type:"series[color]"}],seeAlso:["{@fun table.cell_set_height}, {@fun table.cell_set_text}, {@fun table.cell_set_text_color}, {@fun table.cell_set_text_halign}, {@fun table.cell_set_text_size}, {@fun table.cell_set_text_valign}, {@fun table.cell_set_width}"],syntax:["table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"]},"table.clear":{kind:"Built-in function",desc:[$.t("The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner.",{context:"pine_docs_desc"})],args:[{name:"table_id",info:$.t("A table object.",{context:"pine_docs_args_info"}),type:"series[table]"},{name:"start_column",info:$.t("The index of the column of the first cell to delete. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"start_row",info:$.t("The index of the row of the first cell to delete. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"end_column",info:$.t("The index of the column of the last cell to delete. Optional. The default is the argument used for start_column. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"},{name:"end_row",info:$.t("The index of the row of the last cell to delete. Optional. The default is the argument used for start_row. Numbering starts at 0.",{context:"pine_docs_args_info"}),type:"series[integer]"}],
examples:["//@version=4",'study("A donut", overlay=true)',"if barstate.islast","    colNum = 8, rowNum = 8",'    padding = "◯"',"    donutTable = table.new(position.middle_right, colNum, rowNum)","    for c = 0 to colNum - 1","        for r = 0 to rowNum - 1","            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))","    table.clear(donutTable, 2, 2, 5, 5)"],seeAlso:["{@fun table.delete}, {@fun table.new}"],syntax:["table.clear(table_id, start_column, start_row, end_column, end_row) → void"]}}}}}}]);